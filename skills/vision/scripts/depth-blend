#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "numpy",
#     "pillow",
#     "moderngl",
# ]
# ///
"""
Depth-based blend between two images.
Near objects transition first, background transitions last.

Usage:
  depth-blend image_a.jpg image_b.jpg depth.png output.mp4
  depth-blend image_a.jpg image_b.jpg depth.png output.mp4 --style dissolve
  depth-blend image_a.jpg image_b.jpg depth.png output.mp4 --duration 6
"""

import argparse
import os
import subprocess
import tempfile
import moderngl
import numpy as np
from PIL import Image


def render_depth_wipe_blend(
    image_a_path: str,
    image_b_path: str,
    depth_path: str,
    output_path: str,
    duration: float = 5.0,
    fps: int = 30,
):
    """
    Blend from image A to image B using depth-based wipe.
    Near objects (high depth) transition first, far objects (low depth) last.
    """

    img_a = Image.open(image_a_path).convert("RGB")
    img_b = Image.open(image_b_path).convert("RGB")
    width, height = img_a.size

    # Resize B to match A if needed
    if img_b.size != (width, height):
        img_b = img_b.resize((width, height), Image.Resampling.LANCZOS)

    depth = Image.open(depth_path).convert("L").resize((width, height), Image.Resampling.LANCZOS)

    # Flip for OpenGL
    img_a = img_a.transpose(Image.FLIP_TOP_BOTTOM)
    img_b = img_b.transpose(Image.FLIP_TOP_BOTTOM)
    depth = depth.transpose(Image.FLIP_TOP_BOTTOM)

    ctx = moderngl.create_standalone_context()
    fbo = ctx.framebuffer(color_attachments=[ctx.texture((width, height), 4)])

    vertex_shader = '''
    #version 330
    in vec2 in_vert;
    in vec2 in_texcoord;
    out vec2 v_texcoord;
    void main() {
        gl_Position = vec4(in_vert, 0.0, 1.0);
        v_texcoord = in_texcoord;
    }
    '''

    fragment_shader = '''
    #version 330
    uniform sampler2D u_image_a;
    uniform sampler2D u_image_b;
    uniform sampler2D u_depth;
    uniform float u_progress;
    uniform float u_edge_softness;
    in vec2 v_texcoord;
    out vec4 fragColor;

    void main() {
        vec2 uv = v_texcoord;

        vec3 color_a = texture(u_image_a, uv).rgb;
        vec3 color_b = texture(u_image_b, uv).rgb;
        float depth_val = texture(u_depth, uv).r;

        float threshold = u_progress;
        float blend = smoothstep(
            threshold - u_edge_softness,
            threshold + u_edge_softness,
            depth_val
        );

        vec3 final_color = mix(color_a, color_b, blend);

        // Subtle glow at transition edge
        float edge_dist = abs(depth_val - threshold);
        float edge_glow = exp(-edge_dist * 20.0) * 0.3;
        if (edge_dist < u_edge_softness * 2.0) {
            final_color += vec3(0.2, 0.3, 0.4) * edge_glow * (1.0 - abs(u_progress - 0.5) * 2.0);
        }

        fragColor = vec4(final_color, 1.0);
    }
    '''

    prog = ctx.program(vertex_shader=vertex_shader, fragment_shader=fragment_shader)

    vertices = np.array([
        -1.0, -1.0, 0.0, 0.0,
         1.0, -1.0, 1.0, 0.0,
        -1.0,  1.0, 0.0, 1.0,
         1.0,  1.0, 1.0, 1.0,
    ], dtype='f4')

    vbo = ctx.buffer(vertices)
    vao = ctx.vertex_array(prog, [(vbo, '2f 2f', 'in_vert', 'in_texcoord')])

    img_a_tex = ctx.texture((width, height), 3, np.array(img_a).tobytes())
    img_a_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    img_b_tex = ctx.texture((width, height), 3, np.array(img_b).tobytes())
    img_b_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    depth_tex = ctx.texture((width, height), 1, np.array(depth).tobytes())
    depth_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    img_a_tex.use(0)
    img_b_tex.use(1)
    depth_tex.use(2)

    prog['u_image_a'].value = 0
    prog['u_image_b'].value = 1
    prog['u_depth'].value = 2
    prog['u_edge_softness'].value = 0.15

    with tempfile.TemporaryDirectory() as tmpdir:
        num_frames = int(fps * duration)
        print(f"Rendering depth wipe blend - {num_frames} frames...")

        for frame_idx in range(num_frames):
            t = frame_idx / (num_frames - 1) if num_frames > 1 else 0

            # Smooth ease-in-out
            if t < 0.5:
                progress = 2 * t * t
            else:
                progress = 1 - pow(-2 * t + 2, 2) / 2

            # Expand range for full A at start and full B at end
            progress = progress * 1.3 - 0.15
            progress = max(0.0, min(1.0, progress))

            prog['u_progress'].value = progress

            fbo.use()
            ctx.clear(0.0, 0.0, 0.0, 1.0)
            vao.render(moderngl.TRIANGLE_STRIP)

            data = fbo.read(components=4)
            frame_img = Image.frombytes('RGBA', (width, height), data)
            frame_img = frame_img.transpose(Image.FLIP_TOP_BOTTOM)
            frame_img.save(os.path.join(tmpdir, f'frame_{frame_idx:04d}.png'))

            if (frame_idx + 1) % fps == 0:
                print(f"  {(frame_idx + 1) // fps}s / {int(duration)}s")

        print("Encoding video...")
        subprocess.run([
            'ffmpeg', '-y', '-framerate', str(fps),
            '-i', os.path.join(tmpdir, 'frame_%04d.png'),
            '-c:v', 'libx265', '-crf', '22', '-preset', 'fast',
            '-tag:v', 'hvc1', '-pix_fmt', 'yuv420p', output_path
        ], check=True, capture_output=True)

        print(f"Done! Saved to {output_path} ({os.path.getsize(output_path) / 1024:.1f} KB)")


def render_depth_dissolve(
    image_a_path: str,
    image_b_path: str,
    depth_path: str,
    output_path: str,
    duration: float = 5.0,
    fps: int = 30,
):
    """
    Dissolve with depth-based noise pattern - organic, particle-like transition.
    """

    img_a = Image.open(image_a_path).convert("RGB")
    img_b = Image.open(image_b_path).convert("RGB")
    width, height = img_a.size

    if img_b.size != (width, height):
        img_b = img_b.resize((width, height), Image.Resampling.LANCZOS)

    depth = Image.open(depth_path).convert("L").resize((width, height), Image.Resampling.LANCZOS)

    img_a = img_a.transpose(Image.FLIP_TOP_BOTTOM)
    img_b = img_b.transpose(Image.FLIP_TOP_BOTTOM)
    depth = depth.transpose(Image.FLIP_TOP_BOTTOM)

    ctx = moderngl.create_standalone_context()
    fbo = ctx.framebuffer(color_attachments=[ctx.texture((width, height), 4)])

    vertex_shader = '''
    #version 330
    in vec2 in_vert;
    in vec2 in_texcoord;
    out vec2 v_texcoord;
    void main() {
        gl_Position = vec4(in_vert, 0.0, 1.0);
        v_texcoord = in_texcoord;
    }
    '''

    fragment_shader = '''
    #version 330
    uniform sampler2D u_image_a;
    uniform sampler2D u_image_b;
    uniform sampler2D u_depth;
    uniform float u_progress;
    uniform float u_time;
    in vec2 v_texcoord;
    out vec4 fragColor;

    float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }

    float fbm(vec2 p) {
        float value = 0.0;
        float amplitude = 0.5;
        for (int i = 0; i < 4; i++) {
            value += amplitude * noise(p);
            p *= 2.0;
            amplitude *= 0.5;
        }
        return value;
    }

    void main() {
        vec2 uv = v_texcoord;

        vec3 color_a = texture(u_image_a, uv).rgb;
        vec3 color_b = texture(u_image_b, uv).rgb;
        float depth_val = texture(u_depth, uv).r;

        // Add noise for organic dissolve
        float noise_val = fbm(uv * 20.0 + u_time * 0.5) * 0.3;
        float modified_depth = depth_val + noise_val;

        float threshold = u_progress * 1.4 - 0.2;
        float blend = smoothstep(threshold - 0.05, threshold + 0.05, modified_depth);

        vec3 final_color = mix(color_a, color_b, blend);

        // Sparkle at dissolve edge
        float edge = abs(modified_depth - threshold);
        if (edge < 0.08) {
            float sparkle = pow(hash(uv * 500.0 + u_time), 8.0) * 2.0;
            final_color += vec3(0.8, 0.9, 1.0) * sparkle * (1.0 - edge / 0.08);
        }

        fragColor = vec4(final_color, 1.0);
    }
    '''

    prog = ctx.program(vertex_shader=vertex_shader, fragment_shader=fragment_shader)

    vertices = np.array([
        -1.0, -1.0, 0.0, 0.0,
         1.0, -1.0, 1.0, 0.0,
        -1.0,  1.0, 0.0, 1.0,
         1.0,  1.0, 1.0, 1.0,
    ], dtype='f4')

    vbo = ctx.buffer(vertices)
    vao = ctx.vertex_array(prog, [(vbo, '2f 2f', 'in_vert', 'in_texcoord')])

    img_a_tex = ctx.texture((width, height), 3, np.array(img_a).tobytes())
    img_a_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    img_b_tex = ctx.texture((width, height), 3, np.array(img_b).tobytes())
    img_b_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    depth_tex = ctx.texture((width, height), 1, np.array(depth).tobytes())
    depth_tex.filter = (moderngl.LINEAR, moderngl.LINEAR)

    img_a_tex.use(0)
    img_b_tex.use(1)
    depth_tex.use(2)

    prog['u_image_a'].value = 0
    prog['u_image_b'].value = 1
    prog['u_depth'].value = 2

    with tempfile.TemporaryDirectory() as tmpdir:
        num_frames = int(fps * duration)
        print(f"Rendering depth dissolve - {num_frames} frames...")

        for frame_idx in range(num_frames):
            t = frame_idx / (num_frames - 1) if num_frames > 1 else 0

            if t < 0.5:
                progress = 2 * t * t
            else:
                progress = 1 - pow(-2 * t + 2, 2) / 2

            prog['u_progress'].value = progress
            prog['u_time'].value = frame_idx / fps

            fbo.use()
            ctx.clear(0.0, 0.0, 0.0, 1.0)
            vao.render(moderngl.TRIANGLE_STRIP)

            data = fbo.read(components=4)
            frame_img = Image.frombytes('RGBA', (width, height), data)
            frame_img = frame_img.transpose(Image.FLIP_TOP_BOTTOM)
            frame_img.save(os.path.join(tmpdir, f'frame_{frame_idx:04d}.png'))

            if (frame_idx + 1) % fps == 0:
                print(f"  {(frame_idx + 1) // fps}s / {int(duration)}s")

        print("Encoding video...")
        subprocess.run([
            'ffmpeg', '-y', '-framerate', str(fps),
            '-i', os.path.join(tmpdir, 'frame_%04d.png'),
            '-c:v', 'libx265', '-crf', '22', '-preset', 'fast',
            '-tag:v', 'hvc1', '-pix_fmt', 'yuv420p', output_path
        ], check=True, capture_output=True)

        print(f"Done! Saved to {output_path} ({os.path.getsize(output_path) / 1024:.1f} KB)")


def main():
    parser = argparse.ArgumentParser(
        description='Depth-based blend between two images',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  depth-blend original.jpg stylized.png depth.png output.mp4
  depth-blend a.jpg b.jpg depth.png blend.mp4 --style dissolve --duration 6

The depth map controls transition order:
  - Bright areas (near/foreground) transition first
  - Dark areas (far/background) transition last
'''
    )
    parser.add_argument('image_a', help='First image (start)')
    parser.add_argument('image_b', help='Second image (end)')
    parser.add_argument('depth', help='Depth map (grayscale, bright=near)')
    parser.add_argument('output', help='Output video path (.mp4)')
    parser.add_argument('--style', choices=['wipe', 'dissolve'], default='wipe',
                        help='Blend style: wipe (smooth) or dissolve (sparkly)')
    parser.add_argument('--duration', type=float, default=4.0,
                        help='Video duration in seconds (default: 4)')
    parser.add_argument('--fps', type=int, default=30,
                        help='Frames per second (default: 30)')

    args = parser.parse_args()

    if args.style == 'wipe':
        render_depth_wipe_blend(
            args.image_a, args.image_b, args.depth, args.output,
            duration=args.duration, fps=args.fps
        )
    else:
        render_depth_dissolve(
            args.image_a, args.image_b, args.depth, args.output,
            duration=args.duration, fps=args.fps
        )


if __name__ == '__main__':
    main()
