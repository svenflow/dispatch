#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "numpy",
#     "pillow",
#     "scipy",
#     "pyobjc-framework-Metal",
#     "pyobjc-framework-MetalKit",
#     "pyobjc-framework-Cocoa",
# ]
# ///
"""
Render N-SPECIES Physarum simulation with random projection to RGB.

N separate species, each with own trail. Final color is computed via:
    RGB = projection_matrix @ [trail_0, trail_1, ..., trail_N]

Where projection_matrix is a random 3xN matrix, giving non-axis-aligned colors.

Usage:
    render-physarum-n output.mov --species 3
    render-physarum-n output.mov --species 5 --seed-image photo.png
"""

import argparse
import ctypes
import os
import subprocess
import sys
import tempfile

import Metal
import numpy as np
from PIL import Image
from scipy import ndimage


def generate_metal_source(num_species: int) -> str:
    """Generate Metal shader source for N species."""

    return f"""
#include <metal_stdlib>
using namespace metal;

#define NUM_SPECIES {num_species}

// Agent: x, y, angle, species
struct Agent {{
    float x;
    float y;
    float angle;
    float species;
}};

struct Params {{
    float sensorAngle;
    float sensorDist;
    float turnAngle;
    float moveSpeed;
    float depositAmount;
    float decayFactor;
    int width;
    int height;
    int numAgents;
    float time;
    float crossSense;
    float edgeWeight;
}};

float hash(float2 p, float seed) {{
    float3 p3 = fract(float3(p.xyx) * 0.1031 + seed);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}}

float sampleTrail(device float* trail, float x, float y, int width, int height) {{
    int ix = int(x) % width;
    int iy = int(y) % height;
    if (ix < 0) ix += width;
    if (iy < 0) iy += height;
    return trail[iy * width + ix];
}}

// Sample edge field (same layout as single trail buffer)
float sampleEdge(device float* edgeField, float x, float y, int width, int height) {{
    int ix = int(x) % width;
    int iy = int(y) % height;
    if (ix < 0) ix += width;
    if (iy < 0) iy += height;
    return edgeField[iy * width + ix];
}}

// Sample combined: own pheromone + edge attraction - other species repulsion
float sampleCombined(
    device float* trails,  // All trails concatenated
    device float* edgeField,  // Edge strength map
    float x, float y,
    int width, int height,
    int species,
    float crossSense,
    float edgeWeight
) {{
    float own = sampleTrail(trails + species * width * height, x, y, width, height);
    float edge = sampleEdge(edgeField, x, y, width, height);
    float others = 0.0;
    for (int s = 0; s < NUM_SPECIES; s++) {{
        if (s != species) {{
            others += sampleTrail(trails + s * width * height, x, y, width, height);
        }}
    }}
    // Edge is persistent attractor, others repel
    return own + edgeWeight * edge - crossSense * others / float(NUM_SPECIES - 1);
}}

kernel void updateAgents(
    device Agent* agents [[buffer(0)]],
    device float* trails [[buffer(1)]],  // All species trails concatenated
    device atomic_uint* atomics [[buffer(2)]],  // All atomic buffers concatenated
    constant Params& params [[buffer(3)]],
    device float* edgeField [[buffer(4)]],  // Edge strength from cat image
    uint id [[thread_position_in_grid]]
) {{
    if (id >= uint(params.numAgents)) return;

    Agent agent = agents[id];
    float x = agent.x;
    float y = agent.y;
    float angle = agent.angle;
    int species = int(agent.species);

    // Per-species parameter variation
    float sensorAngle = params.sensorAngle * (1.0 + 0.1 * (float(species) - float(NUM_SPECIES)/2.0));
    float sensorDist = params.sensorDist * (1.0 + 0.05 * float(species));
    float turnAngle = params.turnAngle * (1.0 - 0.05 * float(species));
    float moveSpeed = params.moveSpeed;

    // SENSE (pheromone + edge attraction - other species repulsion)
    float sensorL = sampleCombined(trails, edgeField,
        x + cos(angle - sensorAngle) * sensorDist,
        y + sin(angle - sensorAngle) * sensorDist,
        params.width, params.height, species, params.crossSense, params.edgeWeight);
    float sensorC = sampleCombined(trails, edgeField,
        x + cos(angle) * sensorDist,
        y + sin(angle) * sensorDist,
        params.width, params.height, species, params.crossSense, params.edgeWeight);
    float sensorR = sampleCombined(trails, edgeField,
        x + cos(angle + sensorAngle) * sensorDist,
        y + sin(angle + sensorAngle) * sensorDist,
        params.width, params.height, species, params.crossSense, params.edgeWeight);

    // ROTATE
    float randVal = hash(float2(x, y), params.time + float(id) * 0.001);
    if (sensorC > sensorL && sensorC > sensorR) {{
        // straight
    }} else if (sensorC < sensorL && sensorC < sensorR) {{
        angle += (randVal > 0.5 ? 1.0 : -1.0) * turnAngle;
    }} else if (sensorR > sensorL) {{
        angle += turnAngle;
    }} else {{
        angle -= turnAngle;
    }}

    // MOVE
    float newX = x + cos(angle) * moveSpeed;
    float newY = y + sin(angle) * moveSpeed;
    if (newX < 0) newX += float(params.width);
    if (newX >= float(params.width)) newX -= float(params.width);
    if (newY < 0) newY += float(params.height);
    if (newY >= float(params.height)) newY -= float(params.height);

    // DEPOSIT
    int ix = int(newX);
    int iy = int(newY);
    if (ix >= 0 && ix < params.width && iy >= 0 && iy < params.height) {{
        int idx = species * params.width * params.height + iy * params.width + ix;
        atomic_fetch_add_explicit(&atomics[idx], uint(params.depositAmount * 1000.0), memory_order_relaxed);
    }}

    agents[id].x = newX;
    agents[id].y = newY;
    agents[id].angle = angle;
}}

kernel void applyDeposits(
    device float* trails [[buffer(0)]],
    device atomic_uint* atomics [[buffer(1)]],
    constant Params& params [[buffer(2)]],
    uint2 pos [[thread_position_in_grid]]
) {{
    if (pos.x >= uint(params.width) || pos.y >= uint(params.height)) return;

    int pixelIdx = int(pos.y) * params.width + int(pos.x);
    for (int s = 0; s < NUM_SPECIES; s++) {{
        int idx = s * params.width * params.height + pixelIdx;
        uint val = atomic_exchange_explicit(&atomics[idx], 0, memory_order_relaxed);
        trails[idx] += float(val) / 1000.0;
    }}
}}

kernel void diffuseTrails(
    device float* trailsIn [[buffer(0)]],
    device float* trailsOut [[buffer(1)]],
    constant Params& params [[buffer(2)]],
    uint2 pos [[thread_position_in_grid]]
) {{
    if (pos.x >= uint(params.width) || pos.y >= uint(params.height)) return;

    int x = int(pos.x);
    int y = int(pos.y);
    int w = params.width;
    int h = params.height;
    int pixelIdx = y * w + x;

    for (int s = 0; s < NUM_SPECIES; s++) {{
        float sum = 0.0;
        for (int dy = -1; dy <= 1; dy++) {{
            for (int dx = -1; dx <= 1; dx++) {{
                int nx = (x + dx + w) % w;
                int ny = (y + dy + h) % h;
                sum += trailsIn[s * w * h + ny * w + nx];
            }}
        }}
        // Slightly different decay per species
        float speciesDecay = params.decayFactor * (1.0 - 0.005 * float(s));
        trailsOut[s * w * h + pixelIdx] = (sum / 9.0) * speciesDecay;
    }}
}}
"""


def render_physarum_n(
    output_path: str,
    width: int = 1080,
    height: int = 1080,
    fps: int = 30,
    duration: float = 15.0,
    num_agents: int = 300000,
    num_species: int = 3,
    sensor_angle: float = 0.4,
    sensor_dist: float = 20.0,
    turn_angle: float = 0.3,
    move_speed: float = 1.5,
    deposit: float = 0.8,
    decay: float = 0.97,
    cross_sense: float = 0.5,
    iterations: int = 3,
    seed_image: str = None,
    edge_weight: float = 0.0,
    hq: bool = True,
):
    """Render N-species Physarum with random projection to RGB."""

    device = Metal.MTLCreateSystemDefaultDevice()
    if device is None:
        print("ERROR: No Metal device found", file=sys.stderr)
        sys.exit(1)

    print(f"Using Metal device: {device.name()}")

    # Generate random projection matrix (3 x num_species)
    # Normalize rows to unit length for balanced colors
    np.random.seed(42)  # Reproducible but random-looking
    projection = np.random.randn(3, num_species).astype(np.float32)
    projection = np.abs(projection)  # Non-negative for valid colors
    projection /= projection.sum(axis=1, keepdims=True)  # Normalize rows
    print(f"Projection matrix (3x{num_species}):")
    print(projection)

    # Compile shaders
    metal_source = generate_metal_source(num_species)
    library, error = device.newLibraryWithSource_options_error_(metal_source, None, None)
    if library is None:
        print(f"Shader compilation error: {error}", file=sys.stderr)
        sys.exit(1)

    updateAgentsFn = library.newFunctionWithName_("updateAgents")
    applyDepositsFn = library.newFunctionWithName_("applyDeposits")
    diffuseTrailsFn = library.newFunctionWithName_("diffuseTrails")

    updateAgentsPSO, _ = device.newComputePipelineStateWithFunction_error_(updateAgentsFn, None)
    applyDepositsPSO, _ = device.newComputePipelineStateWithFunction_error_(applyDepositsFn, None)
    diffuseTrailsPSO, _ = device.newComputePipelineStateWithFunction_error_(diffuseTrailsFn, None)

    # Load seed image if provided (needed for both agent seeding and trail initialization)
    seed_arr = None
    edge_arr = None
    if seed_image is not None:
        print(f"Loading seed image: {seed_image}")
        seed_img = Image.open(seed_image).convert('RGB')
        seed_img = seed_img.resize((width, height), Image.LANCZOS)
        seed_arr = np.array(seed_img).astype(np.float32) / 255.0

        # Edge detection using Sobel operator
        if edge_weight > 0:
            print(f"  Computing edge field (edge_weight={edge_weight})")
            # Convert to grayscale for edge detection
            gray = 0.299 * seed_arr[:,:,0] + 0.587 * seed_arr[:,:,1] + 0.114 * seed_arr[:,:,2]

            # Sobel edge detection
            sobel_x = ndimage.sobel(gray, axis=1)
            sobel_y = ndimage.sobel(gray, axis=0)
            edge_magnitude = np.sqrt(sobel_x**2 + sobel_y**2)

            # Normalize to [0, 1] and apply some falloff via gaussian blur
            edge_magnitude = edge_magnitude / (edge_magnitude.max() + 1e-6)

            # Dilate edges slightly so agents can sense them from nearby
            edge_arr = ndimage.gaussian_filter(edge_magnitude, sigma=3.0)
            edge_arr = edge_arr / (edge_arr.max() + 1e-6)
            edge_arr = edge_arr.astype(np.float32)
            print(f"  Edge field: max={edge_arr.max():.3f}, mean={edge_arr.mean():.3f}")

    # Edge field buffer (zeros if no seed image or edge_weight=0)
    edge_field_size = width * height * 4  # float32
    edge_field_buffer = device.newBufferWithLength_options_(edge_field_size, Metal.MTLResourceStorageModeShared)
    if edge_arr is not None:
        edge_flat = edge_arr.flatten().astype(np.float32)
        edge_ptr = (ctypes.c_float * len(edge_flat)).from_buffer(
            edge_field_buffer.contents().as_buffer(edge_field_size))
        for i, v in enumerate(edge_flat):
            edge_ptr[i] = v

    # Initialize agents
    agent_data = np.zeros((num_agents, 4), dtype=np.float32)

    if seed_arr is not None:
        print(f"  Seeding agents from image")
        brightness = 0.299 * seed_arr[:,:,0] + 0.587 * seed_arr[:,:,1] + 0.114 * seed_arr[:,:,2]
        brightness = brightness ** 0.5
        prob = brightness / brightness.sum()
        flat_prob = prob.flatten()

        indices = np.random.choice(len(flat_prob), size=num_agents, p=flat_prob)
        y_coords = indices // width
        x_coords = indices % width

        # Project RGB to species space using inverse projection (pseudo-inverse)
        proj_pinv = np.linalg.pinv(projection)  # (num_species x 3)

        for i in range(num_agents):
            x, y = x_coords[i], y_coords[i]
            rgb = seed_arr[y, x]

            # Project RGB to species weights
            species_weights = proj_pinv @ rgb
            species_weights = np.maximum(species_weights, 0)  # Non-negative
            if species_weights.sum() > 0:
                species_weights /= species_weights.sum()

            # Sample species based on weights
            species = np.random.choice(num_species, p=species_weights)

            agent_data[i, 0] = float(x) + np.random.uniform(-0.5, 0.5)
            agent_data[i, 1] = float(y) + np.random.uniform(-0.5, 0.5)
            agent_data[i, 2] = np.random.uniform(0, 2 * np.pi)
            agent_data[i, 3] = float(species)

        print(f"  Seeded {num_agents} agents from image across {num_species} species")
    else:
        # Random initialization - each species in a wedge
        agents_per_species = num_agents // num_species

        for i in range(num_agents):
            species = min(i // agents_per_species, num_species - 1)

            base_angle = species * 2.0 * np.pi / num_species
            angle = base_angle + np.random.uniform(-np.pi/num_species, np.pi/num_species)
            radius = np.random.uniform(100, min(width, height) * 0.45)

            agent_data[i, 0] = width / 2 + np.cos(angle) * radius
            agent_data[i, 1] = height / 2 + np.sin(angle) * radius
            agent_data[i, 2] = angle + np.random.uniform(-np.pi/4, np.pi/4)
            agent_data[i, 3] = float(species)

    agent_buffer = device.newBufferWithBytes_length_options_(
        agent_data.tobytes(), agent_data.nbytes, Metal.MTLResourceStorageModeShared)

    # Trail buffers - all species concatenated, ping-pong
    trail_size = width * height * num_species * 4  # float32
    trails_a = device.newBufferWithLength_options_(trail_size, Metal.MTLResourceStorageModeShared)
    trails_b = device.newBufferWithLength_options_(trail_size, Metal.MTLResourceStorageModeShared)

    # Initialize trails from seed image so first frame IS the image
    if seed_image is not None:
        # Use pseudo-inverse to project RGB -> species trails
        proj_pinv = np.linalg.pinv(projection)  # (num_species x 3)

        # seed_arr is already loaded above: (H, W, 3)
        # Reshape for matrix multiply: (H*W, 3)
        rgb_flat = seed_arr.reshape(-1, 3)

        # Project to species: (H*W, num_species)
        species_trails = (rgb_flat @ proj_pinv.T).astype(np.float32)
        species_trails = np.maximum(species_trails, 0)  # Non-negative

        # Reshape to (num_species, H, W) and flatten for buffer
        initial_trails = species_trails.T.reshape(num_species, height, width)
        initial_trails_flat = initial_trails.flatten().astype(np.float32)

        # Write to trail buffer
        trails_arr = (ctypes.c_float * len(initial_trails_flat)).from_buffer(
            trails_a.contents().as_buffer(trail_size))
        for i, v in enumerate(initial_trails_flat):
            trails_arr[i] = v

        print(f"  Initialized trails from image - first frame will be exact image")

    # Atomic buffer
    atomic_size = width * height * num_species * 4  # uint32
    atomics = device.newBufferWithLength_options_(atomic_size, Metal.MTLResourceStorageModeShared)

    # Clear atomic buffer
    arr = (ctypes.c_uint32 * (width * height * num_species)).from_buffer(
        atomics.contents().as_buffer(atomic_size))
    for i in range(width * height * num_species):
        arr[i] = 0

    # Params
    class Params(ctypes.Structure):
        _fields_ = [
            ("sensorAngle", ctypes.c_float),
            ("sensorDist", ctypes.c_float),
            ("turnAngle", ctypes.c_float),
            ("moveSpeed", ctypes.c_float),
            ("depositAmount", ctypes.c_float),
            ("decayFactor", ctypes.c_float),
            ("width", ctypes.c_int32),
            ("height", ctypes.c_int32),
            ("numAgents", ctypes.c_int32),
            ("time", ctypes.c_float),
            ("crossSense", ctypes.c_float),
            ("edgeWeight", ctypes.c_float),
        ]

    params = Params(
        sensorAngle=sensor_angle,
        sensorDist=sensor_dist,
        turnAngle=turn_angle,
        moveSpeed=move_speed,
        depositAmount=deposit,
        decayFactor=decay,
        width=width,
        height=height,
        numAgents=num_agents,
        time=0.0,
        crossSense=cross_sense,
        edgeWeight=edge_weight,
    )
    params_buffer = device.newBufferWithBytes_length_options_(
        bytes(params), ctypes.sizeof(params), Metal.MTLResourceStorageModeShared)

    commandQueue = device.newCommandQueue()

    agentThreads = Metal.MTLSizeMake(num_agents, 1, 1)
    agentThreadgroup = Metal.MTLSizeMake(min(256, updateAgentsPSO.maxTotalThreadsPerThreadgroup()), 1, 1)
    trailThreads = Metal.MTLSizeMake(width, height, 1)
    trailThreadgroup = Metal.MTLSizeMake(16, 16, 1)

    curr_trails, next_trails = trails_a, trails_b

    with tempfile.TemporaryDirectory() as tmpdir:
        num_frames = int(fps * duration)
        print(f"Rendering {num_frames} frames at {width}x{height} with {num_agents} agents, {num_species} species...")

        for frame_idx in range(num_frames):
            params.time = frame_idx / fps
            params_ptr = (ctypes.c_char * ctypes.sizeof(params)).from_buffer_copy(bytes(params))
            params_buffer.contents().as_buffer(ctypes.sizeof(params))[:] = bytes(params_ptr)

            for _ in range(iterations):
                commandBuffer = commandQueue.commandBuffer()

                # 1. Update agents
                encoder = commandBuffer.computeCommandEncoder()
                encoder.setComputePipelineState_(updateAgentsPSO)
                encoder.setBuffer_offset_atIndex_(agent_buffer, 0, 0)
                encoder.setBuffer_offset_atIndex_(curr_trails, 0, 1)
                encoder.setBuffer_offset_atIndex_(atomics, 0, 2)
                encoder.setBuffer_offset_atIndex_(params_buffer, 0, 3)
                encoder.setBuffer_offset_atIndex_(edge_field_buffer, 0, 4)
                encoder.dispatchThreads_threadsPerThreadgroup_(agentThreads, agentThreadgroup)
                encoder.endEncoding()

                # 2. Apply deposits
                encoder = commandBuffer.computeCommandEncoder()
                encoder.setComputePipelineState_(applyDepositsPSO)
                encoder.setBuffer_offset_atIndex_(curr_trails, 0, 0)
                encoder.setBuffer_offset_atIndex_(atomics, 0, 1)
                encoder.setBuffer_offset_atIndex_(params_buffer, 0, 2)
                encoder.dispatchThreads_threadsPerThreadgroup_(trailThreads, trailThreadgroup)
                encoder.endEncoding()

                # 3. Diffuse
                encoder = commandBuffer.computeCommandEncoder()
                encoder.setComputePipelineState_(diffuseTrailsPSO)
                encoder.setBuffer_offset_atIndex_(curr_trails, 0, 0)
                encoder.setBuffer_offset_atIndex_(next_trails, 0, 1)
                encoder.setBuffer_offset_atIndex_(params_buffer, 0, 2)
                encoder.dispatchThreads_threadsPerThreadgroup_(trailThreads, trailThreadgroup)
                encoder.endEncoding()

                commandBuffer.commit()
                commandBuffer.waitUntilCompleted()

                curr_trails, next_trails = next_trails, curr_trails

            # Read trails and apply projection to RGB
            all_trails = np.frombuffer(
                curr_trails.contents().as_buffer(trail_size), dtype=np.float32
            ).reshape((num_species, height, width))

            if frame_idx == 0:
                print(f"  Trail stats: max per species = {[f'{t.max():.2f}' for t in all_trails]}")

            # Normalize each species trail
            normalized = np.zeros_like(all_trails)
            for s in range(num_species):
                max_val = max(all_trails[s].max(), 0.01)
                normalized[s] = np.clip(all_trails[s] / max_val, 0, 1)

            # Apply projection: RGB = projection @ trails
            # projection is (3, num_species), normalized is (num_species, H, W)
            rgb = np.tensordot(projection, normalized, axes=([1], [0]))  # (3, H, W)
            rgb = np.transpose(rgb, (1, 2, 0))  # (H, W, 3)

            # Normalize and enhance
            rgb = np.clip(rgb, 0, 1)
            rgb = np.power(rgb, 0.6)  # Gamma

            rgb = (rgb * 255).astype(np.uint8)

            img = Image.fromarray(rgb, 'RGB')
            frame_path = os.path.join(tmpdir, f'frame_{frame_idx:04d}.png')
            img.save(frame_path)

            if (frame_idx + 1) % fps == 0:
                print(f"  {frame_idx + 1}/{num_frames} frames ({(frame_idx + 1) / fps:.0f}s)")

        print("Encoding video with ffmpeg...")

        is_mov = output_path.lower().endswith('.mov')
        if hq:
            ffmpeg_cmd = [
                'ffmpeg', '-y', '-framerate', str(fps),
                '-i', os.path.join(tmpdir, 'frame_%04d.png'),
                '-c:v', 'libx265', '-b:v', '50M', '-maxrate', '60M', '-bufsize', '120M',
                '-preset', 'slow', '-tag:v', 'hvc1', '-pix_fmt', 'yuv420p', '-movflags', '+faststart',
            ]
            if is_mov:
                ffmpeg_cmd.extend(['-brand', 'qt'])
            ffmpeg_cmd.append(output_path)
        else:
            ffmpeg_cmd = [
                'ffmpeg', '-y', '-framerate', str(fps),
                '-i', os.path.join(tmpdir, 'frame_%04d.png'),
                '-c:v', 'libx265', '-crf', '26', '-preset', 'fast',
                '-tag:v', 'hvc1', '-pix_fmt', 'yuv420p', output_path
            ]

        result = subprocess.run(ffmpeg_cmd, capture_output=True)
        if result.returncode != 0:
            print(f"ffmpeg error:\n{result.stderr.decode()}", file=sys.stderr)
            sys.exit(1)

        file_size = os.path.getsize(output_path)
        print(f"Done! Output: {output_path} ({file_size / 1024 / 1024:.1f} MB)")


def main():
    parser = argparse.ArgumentParser(description='Render N-species Physarum with random projection to RGB')
    parser.add_argument('output', help='Output video path')
    parser.add_argument('--width', type=int, default=1080)
    parser.add_argument('--height', type=int, default=1080)
    parser.add_argument('--fps', type=int, default=30)
    parser.add_argument('--duration', type=float, default=15.0)
    parser.add_argument('--agents', type=int, default=300000)
    parser.add_argument('--species', type=int, default=3, help='Number of species')
    parser.add_argument('--sensor-angle', type=float, default=0.4)
    parser.add_argument('--sensor-dist', type=float, default=20.0)
    parser.add_argument('--turn-angle', type=float, default=0.3)
    parser.add_argument('--move-speed', type=float, default=1.5)
    parser.add_argument('--deposit', type=float, default=0.8)
    parser.add_argument('--decay', type=float, default=0.97)
    parser.add_argument('--cross-sense', type=float, default=0.5)
    parser.add_argument('--iterations', type=int, default=3)
    parser.add_argument('--seed-image', type=str, help='Image to seed agent positions from')
    parser.add_argument('--edge-weight', type=float, default=0.0, help='Edge attraction strength (0=off)')
    parser.add_argument('--fast', action='store_true')

    args = parser.parse_args()

    render_physarum_n(
        args.output, args.width, args.height, args.fps, args.duration,
        args.agents, args.species, args.sensor_angle, args.sensor_dist,
        args.turn_angle, args.move_speed, args.deposit, args.decay,
        args.cross_sense, args.iterations, args.seed_image, args.edge_weight,
        hq=not args.fast,
    )


if __name__ == '__main__':
    main()
