#!/usr/bin/env python3
"""
Chrome Control CLI

Control Chrome browser from the command line via native messaging extension.
Supports multiple Chrome profiles simultaneously.

Usage:
    chrome profiles                  List available Chrome profiles
    chrome [-p PROFILE] tabs         List all open tabs
    chrome [-p PROFILE] open <url>   Open new tab with URL
    chrome [-p PROFILE] close <tab_id>  Close a tab
    chrome [-p PROFILE] focus <tab_id>  Focus/activate a tab
    chrome [-p PROFILE] navigate <tab_id> <url>  Navigate tab to URL

    chrome [-p PROFILE] read <tab_id>     Read interactive elements
    chrome [-p PROFILE] text <tab_id>     Get page text content
    chrome [-p PROFILE] html <tab_id>     Get page HTML
    chrome [-p PROFILE] find <tab_id> <query>  Find elements containing text

    chrome [-p PROFILE] click <tab_id> <ref>      Click element by ref
    chrome [-p PROFILE] click-at <tab_id> <x> <y> Click at coordinates
    chrome [-p PROFILE] type <tab_id> <ref> <text> Type into element
    chrome [-p PROFILE] input <tab_id> <ref> <val> Set form input value
    chrome [-p PROFILE] key <tab_id> <key>        Send key
    chrome [-p PROFILE] scroll <tab_id> <dir>     Scroll page
    chrome [-p PROFILE] hover <tab_id> <x> <y>    Hover at coordinates

    chrome [-p PROFILE] screenshot <tab_id>  Take screenshot
    chrome [-p PROFILE] js <tab_id> <code>   Execute JavaScript

    chrome [-p PROFILE] console <tab_id>  Read console messages
    chrome [-p PROFILE] network <tab_id>  Read network requests
    chrome [-p PROFILE] ping              Test connection

Options:
    -p, --profile PROFILE    Target profile (name, email prefix, or index)
                             If omitted, uses first available profile
"""

import sys
import socket
import json
import shutil
import os
from pathlib import Path
from datetime import datetime

REGISTRY_PATH = "/tmp/chrome_control_registry.json"
PICTURES_DIR = Path.home() / "Pictures" / "chrome-screenshots"


def load_registry() -> dict:
    """Load the profile registry."""
    try:
        if os.path.exists(REGISTRY_PATH):
            with open(REGISTRY_PATH, 'r') as f:
                return json.load(f)
    except:
        pass
    return {"profiles": {}}


def get_profiles() -> list:
    """Get list of available profiles."""
    registry = load_registry()
    profiles = []
    for ext_id, info in registry.get("profiles", {}).items():
        socket_path = info.get("socket")
        if socket_path and os.path.exists(socket_path):
            profiles.append({
                "id": ext_id,
                "name": info.get("name", ext_id[:8]),
                "socket": socket_path
            })
    return profiles


def find_profile_socket(profile_selector: str = None) -> str:
    """Find socket path for given profile selector."""
    profiles = get_profiles()

    if not profiles:
        print("Error: No Chrome profiles connected", file=sys.stderr)
        print("Make sure Chrome is running with the extension loaded", file=sys.stderr)
        sys.exit(1)

    if profile_selector is None:
        # Use first available profile
        return profiles[0]["socket"]

    # Try to match by index
    try:
        idx = int(profile_selector)
        if 0 <= idx < len(profiles):
            return profiles[idx]["socket"]
    except ValueError:
        pass

    # Try to match by name (case-insensitive prefix match)
    selector_lower = profile_selector.lower()
    for p in profiles:
        if p["name"].lower().startswith(selector_lower):
            return p["socket"]
        if p["id"].lower().startswith(selector_lower):
            return p["socket"]

    print(f"Error: Profile '{profile_selector}' not found", file=sys.stderr)
    print("Available profiles:", file=sys.stderr)
    for i, p in enumerate(profiles):
        print(f"  {i}: {p['name']}", file=sys.stderr)
    sys.exit(1)


class ChromeControl:
    def __init__(self, socket_path: str):
        self.sock = None
        self.socket_path = socket_path

    def connect(self):
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock.connect(self.socket_path)
        self.sock.settimeout(30)

    def send(self, command: str, timeout: int = 30, **params) -> dict:
        if not self.sock:
            self.connect()
        self.sock.settimeout(timeout)
        msg = json.dumps({"command": command, "params": params})
        self.sock.sendall(msg.encode())
        data = b""
        while b"\n" not in data:
            data += self.sock.recv(65536)
        return json.loads(data.decode().strip())


def get_result(response):
    """Extract result from response, handling errors."""
    if "error" in response:
        print(f"Error: {response['error']}", file=sys.stderr)
        sys.exit(1)
    return response.get("result", response)


def cmd_tabs(client, args):
    """List all open tabs."""
    result = get_result(client.send("list_tabs"))
    tabs = result.get("tabs", [])
    if not tabs:
        print("No tabs open")
        return
    for tab in tabs:
        title = tab.get("title", "")[:50]
        url = tab.get("url", "")[:60]
        print(f"{tab['id']}  {title}")
        print(f"      {url}")


def cmd_open(client, args):
    """Open a new tab with URL."""
    if len(args) < 1:
        print("Usage: chrome open <url>", file=sys.stderr)
        sys.exit(1)
    url = args[0]
    if not url.startswith(("http://", "https://", "file://")):
        url = "https://" + url
    result = get_result(client.send("open_tab", url=url))
    print(f"Opened tab {result.get('tabId')}: {url}")


def cmd_close(client, args):
    """Close a tab."""
    if len(args) < 1:
        print("Usage: chrome close <tab_id>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    get_result(client.send("close_tab", tabId=tab_id))
    print(f"Closed tab {tab_id}")


def cmd_focus(client, args):
    """Focus a tab."""
    if len(args) < 1:
        print("Usage: chrome focus <tab_id>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    get_result(client.send("focus_tab", tabId=tab_id))
    print(f"Focused tab {tab_id}")


def cmd_navigate(client, args):
    """Navigate tab to URL."""
    if len(args) < 2:
        print("Usage: chrome navigate <tab_id> <url|back|forward>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    url = args[1]
    if url not in ("back", "forward") and not url.startswith(("http://", "https://", "file://")):
        url = "https://" + url
    get_result(client.send("navigate", tabId=tab_id, url=url))
    print(f"Navigated tab {tab_id} to {url}")


def cmd_read(client, args):
    """Read interactive elements from page."""
    if len(args) < 1:
        print("Usage: chrome read <tab_id> [filter]", file=sys.stderr)
        print("  Filters: interactive (default), all, forms, links, buttons", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    filter_type = args[1] if len(args) > 1 else "interactive"
    result = get_result(client.send("read_page", tabId=tab_id, filter=filter_type))
    elements = result.get("elements", [])
    if not elements:
        print("No elements found")
        return
    for el in elements:
        ref = el.get("ref", "")
        role = el.get("role", "")
        label = el.get("label", "")[:60] if el.get("label") else ""
        tag = el.get("tag", "")
        line = f"{ref:8} {role:12} {tag:8} {label}"
        print(line)


def cmd_text(client, args):
    """Get page text content."""
    if len(args) < 1:
        print("Usage: chrome text <tab_id>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    result = get_result(client.send("get_page_text", tabId=tab_id))
    print(result if isinstance(result, str) else result.get("text", result))


def cmd_html(client, args):
    """Get page HTML."""
    if len(args) < 1:
        print("Usage: chrome html <tab_id>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    result = get_result(client.send("get_page_html", tabId=tab_id))
    print(result if isinstance(result, str) else result.get("html", result))


def cmd_find(client, args):
    """Find elements by text query."""
    if len(args) < 2:
        print("Usage: chrome find <tab_id> <query>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    query = " ".join(args[1:])
    result = get_result(client.send("find", tabId=tab_id, query=query))
    elements = result.get("elements", result) if isinstance(result, dict) else result
    if not elements:
        print("No matches found")
        return
    for el in (elements if isinstance(elements, list) else [elements]):
        if isinstance(el, dict):
            ref = el.get("ref", "")
            label = el.get("label", "")[:60]
            print(f"{ref:8} {label}")


def cmd_click(client, args):
    """Click element by ref."""
    if len(args) < 2:
        print("Usage: chrome click <tab_id> <ref>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    ref = args[1]
    get_result(client.send("click", tabId=tab_id, selector=ref))
    print(f"Clicked {ref}")


def cmd_click_at(client, args):
    """Click at coordinates."""
    if len(args) < 3:
        print("Usage: chrome click-at <tab_id> <x> <y>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    x, y = int(args[1]), int(args[2])
    get_result(client.send("click_at", tabId=tab_id, x=x, y=y))
    print(f"Clicked at ({x}, {y})")


def cmd_type(client, args):
    """Type text into element."""
    if len(args) < 3:
        print("Usage: chrome type <tab_id> <ref> <text>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    ref = args[1]
    text = " ".join(args[2:])
    get_result(client.send("type", tabId=tab_id, selector=ref, text=text))
    print(f"Typed into {ref}")


def cmd_input(client, args):
    """Set form input value."""
    if len(args) < 3:
        print("Usage: chrome input <tab_id> <ref> <value>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    ref = args[1]
    value = " ".join(args[2:])
    get_result(client.send("form_input", tabId=tab_id, ref=ref, value=value))
    print(f"Set {ref} = {value}")


def cmd_key(client, args):
    """Send key press."""
    if len(args) < 2:
        print("Usage: chrome key <tab_id> <key> [modifiers]", file=sys.stderr)
        print("  Keys: Enter, Tab, Escape, Backspace, ArrowUp, ArrowDown, etc.", file=sys.stderr)
        print("  Modifiers: ctrl, alt, shift, meta (comma-separated)", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    key = args[1]
    modifiers = args[2].split(",") if len(args) > 2 else None
    get_result(client.send("key", tabId=tab_id, key=key, modifiers=modifiers))
    print(f"Sent key: {key}")


def cmd_insert_text(client, args):
    """Insert text at current focus (works in iframes)."""
    if len(args) < 2:
        print("Usage: chrome insert-text <tab_id> <text>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    text = " ".join(args[1:])
    get_result(client.send("insert_text", tabId=tab_id, text=text))
    print(f"Inserted text")


def cmd_iframe_click(client, args):
    """Click element inside iframe by CSS selector."""
    if len(args) < 2:
        print("Usage: chrome iframe-click <tab_id> <selector>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    selector = " ".join(args[1:])
    result = get_result(client.send("iframe_click", tabId=tab_id, selector=selector))
    print(f"Result: {result.get('result', result)}")


def cmd_iframe_type(client, args):
    """Type text using debugger key events (works for iframes)."""
    if len(args) < 2:
        print("Usage: chrome iframe-type <tab_id> <text>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    text = " ".join(args[1:])
    result = get_result(client.send("iframe_type", tabId=tab_id, text=text))
    print(f"Typed: {result}")


def cmd_scroll(client, args):
    """Scroll the page."""
    if len(args) < 2:
        print("Usage: chrome scroll <tab_id> <direction> [amount]", file=sys.stderr)
        print("  Directions: up, down, left, right", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    direction = args[1]
    amount = int(args[2]) if len(args) > 2 else 3
    get_result(client.send("scroll", tabId=tab_id, direction=direction, amount=amount))
    print(f"Scrolled {direction}")


def cmd_hover(client, args):
    """Hover at coordinates."""
    if len(args) < 3:
        print("Usage: chrome hover <tab_id> <x> <y>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    x, y = int(args[1]), int(args[2])
    get_result(client.send("hover", tabId=tab_id, x=x, y=y))
    print(f"Hovering at ({x}, {y})")


def cmd_screenshot(client, args):
    """Take screenshot and save to ~/Pictures."""
    if len(args) < 1:
        print("Usage: chrome screenshot <tab_id>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    result = get_result(client.send("screenshot", timeout=120, tabId=tab_id))

    # Get source path
    src_path = result.get("screenshotPath")
    if not src_path:
        print("Error: No screenshot path returned", file=sys.stderr)
        sys.exit(1)

    # Create destination directory
    PICTURES_DIR.mkdir(parents=True, exist_ok=True)

    # Generate filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    dest_path = PICTURES_DIR / f"screenshot_{timestamp}.jpg"

    # Copy file
    shutil.copy2(src_path, dest_path)

    # Print the path (this is what the user sees)
    print(dest_path)


def cmd_js(client, args):
    """Execute JavaScript in page."""
    if len(args) < 2:
        print("Usage: chrome js <tab_id> <code>", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    code = " ".join(args[1:])
    result = get_result(client.send("javascript", tabId=tab_id, code=code))
    if result is not None:
        if isinstance(result, (dict, list)):
            print(json.dumps(result, indent=2))
        else:
            print(result)


def cmd_console(client, args):
    """Read console messages."""
    if len(args) < 1:
        print("Usage: chrome console <tab_id> [pattern] [--clear]", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    pattern = args[1] if len(args) > 1 and not args[1].startswith("--") else None
    clear = "--clear" in args
    result = get_result(client.send("read_console", tabId=tab_id, pattern=pattern, clear=clear))
    messages = result.get("messages", [])
    for msg in messages:
        print(f"[{msg.get('level', 'log')}] {msg.get('text', msg)}")


def cmd_network(client, args):
    """Read network requests."""
    if len(args) < 1:
        print("Usage: chrome network <tab_id> [url_pattern] [--clear]", file=sys.stderr)
        sys.exit(1)
    tab_id = int(args[0])
    pattern = args[1] if len(args) > 1 and not args[1].startswith("--") else None
    clear = "--clear" in args
    result = get_result(client.send("read_network", tabId=tab_id, urlPattern=pattern, clear=clear))
    requests = result.get("requests", [])
    for req in requests:
        status = req.get("status", "")
        method = req.get("method", "GET")
        url = req.get("url", "")[:80]
        print(f"{status:4} {method:6} {url}")


def cmd_ping(client, args):
    """Test connection to extension."""
    result = get_result(client.send("ping"))
    if result.get("pong"):
        print("Connected to Chrome Control extension")
    else:
        print("Unexpected response", file=sys.stderr)
        sys.exit(1)


def cmd_profiles(client, args):
    """List available Chrome profiles."""
    profiles = get_profiles()
    if not profiles:
        print("No Chrome profiles connected")
        print("Make sure Chrome is running with the extension loaded")
        return
    print(f"Available profiles ({len(profiles)}):")
    for i, p in enumerate(profiles):
        print(f"  {i}: {p['name']}")


def cmd_profile_info(client, args):
    """Get detailed profile info from Chrome identity API."""
    result = get_result(client.send("profile_info"))
    print(f"Email: {result.get('email', 'not available')}")
    print(f"ID: {result.get('id', 'not available')}")
    print(f"Extension ID: {result.get('extensionId', 'unknown')}")
    if result.get('error'):
        print(f"Error: {result.get('error')}")


COMMANDS = {
    "profiles": None,  # Special case - handled before client creation
    "profile-info": cmd_profile_info,
    "tabs": cmd_tabs,
    "open": cmd_open,
    "close": cmd_close,
    "focus": cmd_focus,
    "navigate": cmd_navigate,
    "nav": cmd_navigate,
    "read": cmd_read,
    "text": cmd_text,
    "html": cmd_html,
    "find": cmd_find,
    "click": cmd_click,
    "click-at": cmd_click_at,
    "type": cmd_type,
    "input": cmd_input,
    "key": cmd_key,
    "insert-text": cmd_insert_text,
    "iframe-click": cmd_iframe_click,
    "iframe-type": cmd_iframe_type,
    "scroll": cmd_scroll,
    "hover": cmd_hover,
    "screenshot": cmd_screenshot,
    "shot": cmd_screenshot,
    "js": cmd_js,
    "console": cmd_console,
    "network": cmd_network,
    "ping": cmd_ping,
}


def main():
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help", "help"):
        print(__doc__)
        sys.exit(0)

    # Parse profile flag
    profile_selector = None
    args = sys.argv[1:]

    if args and args[0] in ("-p", "--profile"):
        if len(args) < 2:
            print("Error: --profile requires an argument", file=sys.stderr)
            sys.exit(1)
        profile_selector = args[1]
        args = args[2:]

    if not args:
        print(__doc__)
        sys.exit(0)

    command = args[0]
    cmd_args = args[1:]

    # Handle profiles command (no client needed)
    if command == "profiles":
        cmd_profiles(None, cmd_args)
        return

    if command not in COMMANDS:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("Run 'chrome --help' for usage", file=sys.stderr)
        sys.exit(1)

    try:
        socket_path = find_profile_socket(profile_selector)
        client = ChromeControl(socket_path)
        COMMANDS[command](client, cmd_args)
    except ConnectionRefusedError:
        print("Error: Cannot connect to Chrome Control extension", file=sys.stderr)
        print("Make sure Chrome is running with the extension loaded", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: Chrome profile socket not found", file=sys.stderr)
        print("The profile may have disconnected. Run 'chrome profiles' to check.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
