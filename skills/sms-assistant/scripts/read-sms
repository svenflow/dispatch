#!/usr/bin/env -S uv run --script
"""
read-sms - Read messages from macOS Messages.app

Usage:
    read-sms                                    # Last 20 messages (all chats)
    read-sms --chat +16175551234                # From specific phone (individual)
    read-sms --chat b3d258b9a4de447...          # From group chat (hex UUID)
    read-sms --chat +16175551234 --limit 50     # Last 50 messages
    read-sms --since "2026-01-23 17:00:00"      # Since time
"""

import sqlite3
import argparse
import os
import subprocess
import re
from datetime import datetime

DB_PATH = os.path.expanduser("~/Library/Messages/chat.db")
LOOKUP_SCRIPT = os.path.expanduser("~/.claude/skills/contacts/scripts/lookup_phone.scpt")

# Cache for contact lookups (phone -> (name, tier))
_contact_cache = {}


def lookup_contact(phone):
    """Look up contact name and tier by phone number. Results are cached."""
    if not phone or not os.path.exists(LOOKUP_SCRIPT):
        return None, None

    # Check cache first
    if phone in _contact_cache:
        return _contact_cache[phone]

    try:
        result = subprocess.run(
            ["osascript", LOOKUP_SCRIPT, phone],
            capture_output=True, text=True, timeout=5
        )
        output = result.stdout.strip()
        if output.startswith("FOUND|"):
            parts = output.split("|")
            # FOUND|Name|Phone|Tier
            if len(parts) >= 4:
                _contact_cache[phone] = (parts[1], parts[3])
                return parts[1], parts[3]
    except Exception:
        pass

    _contact_cache[phone] = (None, None)
    return None, None


def is_phone_number(identifier: str) -> bool:
    """Check if identifier looks like a phone number."""
    return identifier.startswith("+") or identifier.replace("-", "").replace(" ", "").isdigit()


def is_group_chat_id(identifier: str) -> bool:
    """Check if identifier looks like a group chat ID (hex string 20+ chars)."""
    return bool(re.match(r'^[a-f0-9]{20,}$', identifier.lower()))


# macOS epoch: 2001-01-01 00:00:00 UTC
MACOS_EPOCH_OFFSET = 978307200


def extract_text_from_attributed_body(data):
    """Extract plain text from NSAttributedString binary data."""
    if not data:
        return None
    try:
        parts = data.split(b"NSString")
        if len(parts) < 2:
            return None
        content = parts[1][5:]
        if content[0] == 0x81:
            length = int.from_bytes(content[1:3], "little")
            text_start = 3
        else:
            length = content[0]
            text_start = 1
        text_bytes = content[text_start:text_start + length]
        return text_bytes.decode("utf-8", errors="ignore")
    except Exception:
        return None


def macos_timestamp_to_datetime(ts):
    """Convert macOS nanosecond timestamp to datetime."""
    if ts is None:
        return None
    unix_ts = ts / 1_000_000_000 + MACOS_EPOCH_OFFSET
    return datetime.fromtimestamp(unix_ts)


def datetime_to_macos_timestamp(dt):
    """Convert datetime to macOS nanosecond timestamp."""
    unix_ts = dt.timestamp()
    return int((unix_ts - MACOS_EPOCH_OFFSET) * 1_000_000_000)


def read_messages(chat_id, since=None, until=None, limit=20):
    """Read messages from chat.db.

    Args:
        chat_id: The chat identifier (phone for individuals, hex UUID for groups) - REQUIRED
        since: Start time filter
        until: End time filter
        limit: Max messages to return
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Query using chat_identifier (works for both individuals and groups)
    query = """
        SELECT
            message.ROWID,
            message.date,
            COALESCE(handle.id, 'me') as phone,
            message.is_from_me,
            message.text,
            message.attributedBody
        FROM message
        INNER JOIN chat_message_join ON message.ROWID = chat_message_join.message_id
        INNER JOIN chat ON chat_message_join.chat_id = chat.ROWID
        LEFT JOIN handle ON message.handle_id = handle.ROWID
        WHERE chat.chat_identifier = ?
    """
    params = [chat_id]

    if since:
        since_dt = datetime.strptime(since, "%Y-%m-%d %H:%M:%S")
        since_ts = datetime_to_macos_timestamp(since_dt)
        query += " AND message.date >= ?"
        params.append(since_ts)

    if until:
        until_dt = datetime.strptime(until, "%Y-%m-%d %H:%M:%S")
        until_ts = datetime_to_macos_timestamp(until_dt)
        query += " AND message.date <= ?"
        params.append(until_ts)

    query += " ORDER BY message.date DESC LIMIT ?"
    params.append(limit)

    cursor.execute(query, params)
    rows = cursor.fetchall()
    conn.close()

    messages = []
    for row in rows:
        rowid, date, phone, is_from_me, text, attributed_body = row

        # Try to get text from text field first, then attributedBody
        msg_text = text
        if not msg_text and attributed_body:
            msg_text = extract_text_from_attributed_body(attributed_body)

        # Skip empty messages and attachment-only messages
        if not msg_text or msg_text == '\ufffc':
            continue

        timestamp = macos_timestamp_to_datetime(date)
        direction = "OUT" if is_from_me else "IN"

        messages.append({
            "rowid": rowid,
            "timestamp": timestamp.strftime("%Y-%m-%d %H:%M:%S") if timestamp else None,
            "phone": phone,
            "direction": direction,
            "text": msg_text.replace('\n', ' ')
        })

    return list(reversed(messages))  # Return in chronological order


def main():
    parser = argparse.ArgumentParser(
        description="Read messages from macOS Messages.app",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  read-sms --chat +16175551234           # Individual chat by phone
  read-sms --chat b3d258b9a4de447...     # Group chat by UUID
  read-sms --chat +16175551234 --limit 50
  read-sms --chat +16175551234 --since "2026-01-23 17:00:00"
"""
    )
    parser.add_argument("--chat", required=True, help="Chat identifier (phone number or group UUID) - REQUIRED")
    parser.add_argument("--since", help="Start time (YYYY-MM-DD HH:MM:SS)")
    parser.add_argument("--until", help="End time (YYYY-MM-DD HH:MM:SS)")
    parser.add_argument("--limit", type=int, default=20, help="Max messages to return (default: 20)")
    args = parser.parse_args()

    # Print header with chat info
    if args.chat:
        if is_phone_number(args.chat):
            contact_name, tier = lookup_contact(args.chat)
            if contact_name:
                print(f"# Chat: {contact_name} | Tier: {tier} | ID: {args.chat}")
            else:
                print(f"# Chat: {args.chat} (not in contacts)")
        elif is_group_chat_id(args.chat):
            print(f"# Group Chat: {args.chat}")
        else:
            print(f"# Chat: {args.chat}")
        print()

    messages = read_messages(
        chat_id=args.chat,
        since=args.since,
        until=args.until,
        limit=args.limit
    )

    for msg in messages:
        print(f"{msg['timestamp']} | {msg['phone']} | {msg['direction']} | {msg['text']}")


if __name__ == "__main__":
    main()
