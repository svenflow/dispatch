# Patched mesh_utils.py - uses trimesh instead of bpy for Modal compatibility
# This replaces hy3dpaint/DifferentiableRenderer/mesh_utils.py to work without Blender
import trimesh
import numpy as np
import os
import cv2


def _safe_extract_attribute(obj, attr_path, default=None):
    """Safely extract nested attributes from objects."""
    try:
        result = obj
        for attr in attr_path.split('.'):
            result = getattr(result, attr)
        return result
    except AttributeError:
        return default


def _convert_to_numpy(data, dtype):
    """Convert data to numpy arrays with specified dtype."""
    if data is None:
        return None
    return np.array(data, dtype=dtype)


def load_mesh(mesh):
    """Load mesh data including vertices, faces, UV coords, and textures.

    For file paths, loads from file. For trimesh objects, extracts data directly.
    """
    if isinstance(mesh, str):
        # Load from file path
        loaded = trimesh.load(mesh, process=False)
        if isinstance(loaded, trimesh.Scene):
            meshes = [g for g in loaded.geometry.values() if isinstance(g, trimesh.Trimesh)]
            if meshes:
                loaded = trimesh.util.concatenate(meshes)
            else:
                raise ValueError(f"No meshes found in {mesh}")
        mesh = loaded

    # Extract mesh data
    vtx_pos = _convert_to_numpy(mesh.vertices, np.float32)
    pos_idx = _convert_to_numpy(mesh.faces, np.int32)

    # Try to extract UV coordinates
    vtx_uv = None
    uv_idx = None
    if hasattr(mesh.visual, 'uv') and mesh.visual.uv is not None:
        vtx_uv = _convert_to_numpy(mesh.visual.uv, np.float32)
        uv_idx = pos_idx.copy()  # Same face indices for UV

    # Extract texture if present
    texture = None
    if hasattr(mesh.visual, 'material') and hasattr(mesh.visual.material, 'image'):
        if mesh.visual.material.image is not None:
            texture = np.array(mesh.visual.material.image)

    return {
        'vtx_pos': vtx_pos,
        'pos_idx': pos_idx,
        'vtx_uv': vtx_uv,
        'uv_idx': uv_idx,
        'texture': texture,
    }


def _get_base_path_and_name(mesh_path):
    """Extract base path and mesh name from file path."""
    base_path = os.path.splitext(mesh_path)[0]
    name = os.path.basename(base_path)
    return base_path, name


def _save_texture_map(texture, base_path, suffix, image_format='png', color_convert=None):
    """Save texture map to file."""
    if texture is None:
        return None

    path = f"{base_path}_{suffix}.{image_format}"
    if color_convert is not None:
        texture = cv2.cvtColor(texture, color_convert)
    cv2.imwrite(path, texture)
    return path


def _write_mtl_properties(f, properties):
    """Write material properties to MTL file."""
    for key, value in properties.items():
        if isinstance(value, (list, tuple)):
            f.write(f"{key} {' '.join(map(str, value))}\n")
        else:
            f.write(f"{key} {value}\n")


def _create_obj_content(vtx_pos, vtx_uv, pos_idx, uv_idx, name):
    """Generate OBJ file content from mesh data."""
    lines = [f"# OBJ file generated by mesh_utils_patch\n"]
    lines.append(f"mtllib {name}.mtl\n")
    lines.append(f"usemtl material0\n")

    # Write vertices
    for v in vtx_pos:
        lines.append(f"v {v[0]} {v[1]} {v[2]}\n")

    # Write UV coords if present
    if vtx_uv is not None:
        for uv in vtx_uv:
            lines.append(f"vt {uv[0]} {uv[1]}\n")

    # Write faces
    for i, face in enumerate(pos_idx):
        if vtx_uv is not None and uv_idx is not None:
            uv_face = uv_idx[i]
            lines.append(f"f {face[0]+1}/{uv_face[0]+1} {face[1]+1}/{uv_face[1]+1} {face[2]+1}/{uv_face[2]+1}\n")
        else:
            lines.append(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")

    return ''.join(lines)


def save_obj_mesh(mesh_path, vtx_pos, pos_idx, vtx_uv=None, uv_idx=None,
                  texture=None, metallic=None, roughness=None, normal=None):
    """Save mesh as OBJ format with textures and materials."""
    base_path, name = _get_base_path_and_name(mesh_path)

    # Save OBJ file
    obj_content = _create_obj_content(vtx_pos, vtx_uv, pos_idx, uv_idx, name)
    with open(mesh_path, 'w') as f:
        f.write(obj_content)

    # Save textures
    tex_path = _save_texture_map(texture, base_path, 'diffuse', color_convert=cv2.COLOR_RGB2BGR)
    metal_path = _save_texture_map(metallic, base_path, 'metallic')
    rough_path = _save_texture_map(roughness, base_path, 'roughness')
    norm_path = _save_texture_map(normal, base_path, 'normal', color_convert=cv2.COLOR_RGB2BGR)

    # Create MTL file
    _create_mtl_file(base_path, {
        'diffuse': tex_path,
        'metallic': metal_path,
        'roughness': rough_path,
        'normal': norm_path,
    }, is_pbr=(metallic is not None or roughness is not None))

    return mesh_path


def _create_mtl_file(base_path, texture_maps, is_pbr=False):
    """Create MTL material file."""
    mtl_path = f"{base_path}.mtl"
    name = os.path.basename(base_path)

    with open(mtl_path, 'w') as f:
        f.write(f"# MTL file generated by mesh_utils_patch\n")
        f.write(f"newmtl material0\n")

        if texture_maps.get('diffuse'):
            f.write(f"map_Kd {os.path.basename(texture_maps['diffuse'])}\n")
        if texture_maps.get('normal'):
            f.write(f"bump {os.path.basename(texture_maps['normal'])}\n")

        # PBR properties (for reference, may not be standard MTL)
        if is_pbr:
            if texture_maps.get('metallic'):
                f.write(f"map_Pm {os.path.basename(texture_maps['metallic'])}\n")
            if texture_maps.get('roughness'):
                f.write(f"map_Pr {os.path.basename(texture_maps['roughness'])}\n")


def save_mesh(mesh_path, vtx_pos, pos_idx, vtx_uv=None, uv_idx=None,
              texture=None, metallic=None, roughness=None, normal=None):
    """Wrapper that delegates to save_obj_mesh."""
    return save_obj_mesh(mesh_path, vtx_pos, pos_idx, vtx_uv, uv_idx,
                         texture, metallic, roughness, normal)


def convert_obj_to_glb(obj_path, glb_path, shade_type='smooth',
                       auto_smooth_angle=None, merge_vertices=True):
    """Convert OBJ file to GLB format using trimesh (replaces Blender version).

    Args:
        obj_path: Path to input OBJ file
        glb_path: Path for output GLB file
        shade_type: 'smooth', 'flat', or 'auto' shading
        auto_smooth_angle: Angle for auto-smooth (degrees), unused in trimesh
        merge_vertices: Whether to merge duplicate vertices

    Returns:
        True on success, False on failure
    """
    try:
        # Load OBJ file
        mesh = trimesh.load(obj_path, process=False)

        if isinstance(mesh, trimesh.Scene):
            # If scene, try to get all meshes
            meshes = [g for g in mesh.geometry.values() if isinstance(g, trimesh.Trimesh)]
            if meshes:
                mesh = trimesh.util.concatenate(meshes)
            else:
                print(f"No meshes found in {obj_path}")
                return False

        # Merge vertices if requested (equivalent to bpy.ops.mesh.remove_doubles)
        if merge_vertices:
            mesh.merge_vertices()

        # Handle shading by computing normals
        if shade_type == 'smooth':
            # Smooth shading - vertex normals are averaged across faces
            mesh.vertex_normals  # This computes smooth vertex normals
        elif shade_type == 'flat':
            # Flat shading - unshare vertices so each face has its own
            mesh.unmerge_vertices()
        # auto shading: use defaults

        # Export to GLB
        mesh.export(glb_path, file_type='glb')
        return True

    except Exception as e:
        print(f"convert_obj_to_glb failed: {e}")
        return False
