#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "rich",
# ]
# ///
"""
Realtor.com property search CLI.

Uses Chrome to navigate and extract data from __NEXT_DATA__.

Usage:
    realtor search "Vermont" --beds 3 --baths 3 --min-acres 10
    realtor search "Starksboro, VT"
"""

import argparse
import json
import os
import re
import subprocess
import sys
import urllib.parse
from rich.console import Console
from rich.table import Table

console = Console()

CHROME_CLI = os.path.expanduser("~/.claude/skills/chrome-control/scripts/chrome")

def get_chrome_tab(site_pattern: str, open_url: str = None) -> str:
    """Find or open a Chrome tab matching the pattern."""
    result = subprocess.run([CHROME_CLI, "tabs"], capture_output=True, text=True)

    tab_id = None
    lines = result.stdout.strip().split('\n')
    for i, line in enumerate(lines):
        if site_pattern in line.lower():
            if i > 0:
                tab_id = lines[i-1].split()[0]
            break
        parts = line.split()
        if len(parts) >= 2 and parts[0].isdigit() and site_pattern in line.lower():
            tab_id = parts[0]
            break

    if not tab_id and open_url:
        console.print(f"[yellow]Opening {site_pattern}...[/yellow]")
        result = subprocess.run([CHROME_CLI, "open", open_url], capture_output=True, text=True)
        match = re.search(r'Opened tab (\d+)', result.stdout)
        if match:
            tab_id = match.group(1)
            import time
            time.sleep(3)

    if not tab_id:
        raise RuntimeError(f"Could not find or open {site_pattern} tab")

    return tab_id

def build_search_url(location: str, **filters) -> str:
    """Build Realtor.com search URL."""
    # Format location for URL
    location_slug = location.replace(',', '').replace(' ', '-')

    # Build filter string
    filter_parts = []

    if filters.get('min_beds'):
        filter_parts.append(f"beds-{filters['min_beds']}")
    if filters.get('min_baths'):
        filter_parts.append(f"baths-{filters['min_baths']}")
    if filters.get('min_price'):
        filter_parts.append(f"price-{filters['min_price']}-na")
    if filters.get('max_price'):
        if filters.get('min_price'):
            filter_parts[-1] = f"price-{filters['min_price']}-{filters['max_price']}"
        else:
            filter_parts.append(f"price-na-{filters['max_price']}")
    if filters.get('min_sqft'):
        filter_parts.append(f"sqft-{filters['min_sqft']}-na")
    if filters.get('min_lot_sqft'):
        filter_parts.append(f"lot-{filters['min_lot_sqft']}-na")

    filter_str = '/'.join(filter_parts) if filter_parts else ''

    base_url = f"https://www.realtor.com/realestateandhomes-search/{location_slug}"
    if filter_str:
        base_url += f"/{filter_str}"

    return base_url

def extract_search_results(tab_id: str) -> dict:
    """Extract search results from Realtor.com page."""
    js_code = """
    const data = window.__NEXT_DATA__?.props?.pageProps;
    if (data?.properties) {
        JSON.stringify({
            total: data.totalProperties,
            results: data.properties.map(r => ({
                property_id: r.property_id,
                address: r.location?.address?.line,
                city: r.location?.address?.city,
                state: r.location?.address?.state_code,
                zip: r.location?.address?.postal_code,
                price: r.list_price,
                beds: r.description?.beds,
                baths: r.description?.baths,
                sqft: r.description?.sqft,
                lot_sqft: r.description?.lot_sqft,
                lot_acres: r.description?.lot_sqft ? r.description.lot_sqft / 43560 : null,
                status: r.status,
                type: r.description?.type,
                year_built: r.description?.year_built,
                photo: r.primary_photo?.href,
            }))
        });
    } else {
        JSON.stringify({error: 'No properties found', keys: Object.keys(data || {})});
    }
    """
    result = subprocess.run(
        [CHROME_CLI, "js", tab_id, js_code],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        return {"error": result.stderr}

    try:
        return json.loads(result.stdout.strip())
    except json.JSONDecodeError:
        return {"error": "Could not parse results", "raw": result.stdout[:500]}

def format_search_results(data: dict) -> None:
    """Pretty print search results."""
    if 'error' in data:
        console.print(f"[red]Error: {data['error']}[/red]")
        return

    total = data.get('total', 0)
    results = data.get('results', [])

    console.print(f"\n[bold green]Found {total} properties[/bold green]")

    if not results:
        return

    table = Table()
    table.add_column("Address", style="cyan", max_width=35)
    table.add_column("Price", justify="right")
    table.add_column("Bed/Bath")
    table.add_column("Sqft")
    table.add_column("Acres", justify="right")
    table.add_column("ID")

    for r in results[:20]:
        price = f"${r.get('price', 0):,}" if r.get('price') else 'N/A'
        beds_baths = f"{r.get('beds', '?')}/{r.get('baths', '?')}"
        sqft = f"{r.get('sqft', 0):,}" if r.get('sqft') else 'N/A'
        acres = f"{r.get('lot_acres', 0):.1f}" if r.get('lot_acres') else 'N/A'

        full_address = f"{r.get('address', 'N/A')}, {r.get('city', '')}"

        table.add_row(
            full_address[:35],
            price,
            beds_baths,
            sqft,
            acres,
            str(r.get('property_id', 'N/A'))[:12]
        )

    console.print(table)

def main():
    parser = argparse.ArgumentParser(description="Realtor.com property search CLI")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Search command
    search_parser = subparsers.add_parser("search", help="Search for properties")
    search_parser.add_argument("location", help="Location to search (e.g., 'Vermont', 'Starksboro, VT')")
    search_parser.add_argument("--beds", type=int, help="Minimum bedrooms")
    search_parser.add_argument("--baths", type=int, help="Minimum bathrooms")
    search_parser.add_argument("--min-price", type=int, help="Minimum price")
    search_parser.add_argument("--max-price", type=int, help="Maximum price")
    search_parser.add_argument("--min-sqft", type=int, help="Minimum square feet")
    search_parser.add_argument("--min-acres", type=float, help="Minimum lot size in acres")
    search_parser.add_argument("--json", action="store_true", help="Output raw JSON")

    args = parser.parse_args()

    if args.command == "search":
        # Build search URL with filters
        filters = {}
        if args.beds:
            filters['min_beds'] = args.beds
        if args.baths:
            filters['min_baths'] = args.baths
        if args.min_price:
            filters['min_price'] = args.min_price
        if args.max_price:
            filters['max_price'] = args.max_price
        if args.min_sqft:
            filters['min_sqft'] = args.min_sqft
        if args.min_acres:
            filters['min_lot_sqft'] = int(args.min_acres * 43560)

        url = build_search_url(args.location, **filters)

        # Open or navigate to search URL
        tab_id = get_chrome_tab('realtor.com', url)

        # Navigate to the search URL
        subprocess.run([CHROME_CLI, "navigate", tab_id, url], capture_output=True)

        import time
        time.sleep(3)

        # Extract results
        data = extract_search_results(tab_id)

        if args.json:
            print(json.dumps(data, indent=2))
        else:
            format_search_results(data)

    else:
        parser.print_help()

if __name__ == "__main__":
    main()
