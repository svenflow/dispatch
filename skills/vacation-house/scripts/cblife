#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = ["requests", "rich", "beautifulsoup4"]
# ///
"""
Coldwell Banker Lifestyles (thecblife.com) CLI - VT/NH/ME ski properties

Scrapes ski home listings from embedded JavaScript data.

Usage:
    cblife search                      # All ski homes
    cblife search --state VT           # Vermont only
    cblife search --beds 3             # 3+ bedrooms
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from pathlib import Path

import requests
from bs4 import BeautifulSoup
from rich.console import Console
from rich.table import Table

console = Console()

CHROME_CLI = Path.home() / ".claude/skills/chrome-control/scripts/chrome"

# Ski home URLs by state
SKI_URLS = {
    "all": "https://www.thecblife.com/ski-homes/",
    "vt": "https://www.thecblife.com/vermont-ski-homes-for-sale/",
    "nh": "https://www.thecblife.com/new-hampshire-ski-homes/",
    # ME ski homes are part of the NH page or general ski-homes
}


def get_chrome_tab(site_pattern: str, open_url: str = None) -> str:
    """Find or open a Chrome tab matching the pattern."""
    result = subprocess.run([str(CHROME_CLI), "tabs"], capture_output=True, text=True)

    tab_id = None
    lines = result.stdout.strip().split('\n')
    for i, line in enumerate(lines):
        if site_pattern in line.lower():
            if i > 0:
                prev_line = lines[i - 1].strip()
                parts = prev_line.split()
                if parts and parts[0].isdigit():
                    tab_id = parts[0]
                    break

    if not tab_id and open_url:
        result = subprocess.run(
            [str(CHROME_CLI), "open", open_url],
            capture_output=True,
            text=True,
        )
        match = re.search(r'Opened tab (\d+)', result.stdout)
        if match:
            tab_id = match.group(1)
            time.sleep(4)

    if not tab_id:
        raise RuntimeError(f"Could not find or open {site_pattern} tab")

    return tab_id


def extract_listings(tab_id: str) -> list[dict]:
    """Extract listings from thecblife page."""
    # The site embeds property data in JavaScript objects
    js_code = """
    const listings = [];

    // Try to find embedded property data
    const scripts = document.querySelectorAll('script');
    for (const script of scripts) {
        const text = script.textContent;
        if (text && text.includes('properties') && text.includes('listPrice')) {
            // Found property data script
            try {
                // Look for JSON-like property arrays
                const matches = text.match(/\\[\\s*\\{[^\\]]*"listPrice"[^\\]]*\\]/g);
                if (matches) {
                    for (const m of matches) {
                        try {
                            const props = JSON.parse(m);
                            for (const p of props) {
                                listings.push({
                                    price: p.listPrice || p.price,
                                    address: p.streetAddress || p.address,
                                    city: p.city,
                                    state: p.state,
                                    beds: p.bedroomsTotal || p.bedrooms,
                                    baths: p.bathroomsTotalInteger || p.bathrooms,
                                    sqft: p.buildingAreaTotal || p.sqft,
                                    acres: p.lotSizeAcres || p.acres,
                                    type: p.propertyType || p.usmPropertyType,
                                    url: p.url || p.detailUrl,
                                    image: p.photoUrl || p.photo,
                                    mls: p.mlsId || p.listingId
                                });
                            }
                        } catch (e) {}
                    }
                }
            } catch (e) {}
        }
    }

    // Fallback: parse listing cards from DOM
    if (listings.length === 0) {
        document.querySelectorAll('.property-card, .listing-card, [class*="property"], article').forEach(el => {
            const getText = (sel) => {
                const e = el.querySelector(sel);
                return e ? e.textContent.trim() : null;
            };
            const getAttr = (sel, attr) => {
                const e = el.querySelector(sel);
                return e ? e.getAttribute(attr) : null;
            };

            const priceText = getText('[class*="price"], .price') || '';
            const price = parseInt(priceText.replace(/[^0-9]/g, '')) || null;

            const address = getText('[class*="address"], .address, h2, h3');
            const beds = getText('[class*="bed"]');
            const baths = getText('[class*="bath"]');
            const sqft = getText('[class*="sqft"], [class*="area"]');
            const acres = getText('[class*="acre"], [class*="lot"]');

            const link = getAttr('a', 'href');
            const img = getAttr('img', 'src');

            if (address || price) {
                listings.push({
                    price: price,
                    address: address,
                    beds: beds ? parseInt(beds.replace(/[^0-9]/g, '')) : null,
                    baths: baths ? parseFloat(baths.replace(/[^0-9.]/g, '')) : null,
                    sqft: sqft ? parseInt(sqft.replace(/[^0-9]/g, '')) : null,
                    acres: acres ? parseFloat(acres.replace(/[^0-9.]/g, '')) : null,
                    url: link,
                    image: img
                });
            }
        });
    }

    JSON.stringify(listings);
    """

    result = subprocess.run(
        [str(CHROME_CLI), "js", tab_id, js_code],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        console.print(f"[red]Error extracting listings: {result.stderr}[/red]")
        return []

    try:
        return json.loads(result.stdout.strip())
    except json.JSONDecodeError:
        console.print(f"[yellow]Could not parse listings[/yellow]")
        return []


def cmd_search(args):
    """Search for ski home listings."""
    # Choose URL based on state filter
    state = (args.state or "all").lower()
    url = SKI_URLS.get(state, SKI_URLS["all"])

    console.print(f"[dim]Loading: {url}[/dim]")

    # Open or navigate to URL
    tab_id = get_chrome_tab('thecblife', url)
    subprocess.run([str(CHROME_CLI), "navigate", tab_id, url], capture_output=True)
    time.sleep(4)

    # Extract listings
    listings = extract_listings(tab_id)

    # Filter out condos/townhomes
    listings = [l for l in listings if not any(
        t in str(l.get('type', '')).lower()
        for t in ['condo', 'townhouse', 'townhome']
    )]

    # Apply filters
    if args.min_beds:
        listings = [l for l in listings if l.get('beds') and l['beds'] >= args.min_beds]
    if args.min_baths:
        listings = [l for l in listings if l.get('baths') and l['baths'] >= args.min_baths]
    if args.min_price:
        listings = [l for l in listings if l.get('price') and l['price'] >= args.min_price]
    if args.max_price:
        listings = [l for l in listings if l.get('price') and l['price'] <= args.max_price]
    if args.min_acres:
        listings = [l for l in listings if l.get('acres') and l['acres'] >= args.min_acres]

    if args.json:
        print(json.dumps(listings, indent=2))
        return 0

    state_label = state.upper() if state != "all" else "VT/NH/ME"
    console.print(f"\n[bold]Coldwell Banker {state_label} Ski Homes[/bold] - {len(listings)} listings\n")

    if not listings:
        console.print("[yellow]No listings found matching criteria[/yellow]")
        return 0

    table = Table()
    table.add_column("Price", style="green", justify="right")
    table.add_column("Beds", justify="center")
    table.add_column("Baths", justify="center")
    table.add_column("SqFt", justify="right")
    table.add_column("Acres", justify="right")
    table.add_column("Address", style="cyan")
    table.add_column("City", style="dim")

    for l in listings[:20]:
        price_str = f"${l['price']:,}" if l.get('price') else "-"
        beds_str = str(l.get('beds', '-'))
        baths_str = str(l.get('baths', '-'))
        sqft_str = f"{l['sqft']:,}" if l.get('sqft') else "-"
        acres_str = f"{l['acres']:.2f}" if l.get('acres') else "-"
        addr = l.get('address', 'N/A')
        city = l.get('city', '')

        table.add_row(price_str, beds_str, baths_str, sqft_str, acres_str, addr[:35], city[:15])

    console.print(table)

    if len(listings) > 20:
        console.print(f"\n[dim]Showing 20 of {len(listings)} results[/dim]")

    return 0


def main():
    parser = argparse.ArgumentParser(description="Coldwell Banker Lifestyles Ski Homes")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    search_parser = subparsers.add_parser("search", help="Search ski home listings")
    search_parser.add_argument("--state", help="State filter (VT, NH, or all)")
    search_parser.add_argument("--min-beds", type=int, help="Minimum bedrooms")
    search_parser.add_argument("--min-baths", type=int, help="Minimum bathrooms")
    search_parser.add_argument("--min-price", type=int, help="Minimum price")
    search_parser.add_argument("--max-price", type=int, help="Maximum price")
    search_parser.add_argument("--min-acres", type=float, help="Minimum acreage")
    search_parser.add_argument("--json", action="store_true", help="Output JSON")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    if args.command == "search":
        return cmd_search(args)

    return 0


if __name__ == "__main__":
    sys.exit(main())
