#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "rich",
# ]
# ///
"""
Zillow property search CLI.

Uses Chrome to get cookies, then queries via page data extraction.

Usage:
    zillow search "Vermont" --beds 3 --baths 3 --min-acres 10
    zillow lookup "206 Conway Road, Starksboro VT"
    zillow details 81624154
"""

import argparse
import json
import os
import re
import subprocess
import sys
import urllib.parse
import requests
from rich.console import Console
from rich.table import Table

console = Console()

CHROME_CLI = os.path.expanduser("~/.claude/skills/chrome-control/scripts/chrome")

def get_chrome_tab(site_pattern: str, open_url: str = None) -> str:
    """Find or open a Chrome tab matching the pattern."""
    result = subprocess.run([CHROME_CLI, "tabs"], capture_output=True, text=True)

    tab_id = None
    lines = result.stdout.strip().split('\n')
    for i, line in enumerate(lines):
        if site_pattern in line.lower():
            if i > 0:
                tab_id = lines[i-1].split()[0]
            break
        parts = line.split()
        if len(parts) >= 2 and parts[0].isdigit() and site_pattern in line.lower():
            tab_id = parts[0]
            break

    if not tab_id and open_url:
        console.print(f"[yellow]Opening {site_pattern} to get fresh cookies...[/yellow]")
        result = subprocess.run([CHROME_CLI, "open", open_url], capture_output=True, text=True)
        match = re.search(r'Opened tab (\d+)', result.stdout)
        if match:
            tab_id = match.group(1)
            import time
            time.sleep(3)

    if not tab_id:
        raise RuntimeError(f"Could not find or open {site_pattern} tab")

    return tab_id

def get_chrome_cookies(tab_id: str) -> str:
    """Extract cookies from a Chrome tab."""
    result = subprocess.run(
        [CHROME_CLI, "js", tab_id, "document.cookie"],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        raise RuntimeError(f"Could not get cookies: {result.stderr}")
    return result.stdout.strip()

def zillow_autocomplete(query: str) -> dict:
    """Search for properties/locations via Zillow autocomplete."""
    # This endpoint doesn't need cookies
    url = "https://www.zillowstatic.com/autocomplete/v3/suggestions"
    params = {'q': query}

    headers = {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': '*/*',
    }

    response = requests.get(url, params=params, headers=headers)
    response.raise_for_status()
    return response.json()

def build_search_url(region: str, **filters) -> str:
    """Build Zillow search URL with filters."""
    # searchQueryState format
    filter_state = {
        "sort": {"value": "days"},  # Sort by newest
        "ah": {"value": True},  # Include pending/accepting backups
    }

    if filters.get('min_beds'):
        filter_state["beds"] = {"min": filters['min_beds']}
    if filters.get('min_baths'):
        filter_state["baths"] = {"min": filters['min_baths']}
    if filters.get('min_price'):
        filter_state["price"] = filter_state.get("price", {})
        filter_state["price"]["min"] = filters['min_price']
    if filters.get('max_price'):
        filter_state["price"] = filter_state.get("price", {})
        filter_state["price"]["max"] = filters['max_price']
    if filters.get('min_sqft'):
        filter_state["sqft"] = {"min": filters['min_sqft']}
    if filters.get('min_lot_sqft'):
        filter_state["lot"] = {"min": filters['min_lot_sqft']}
    if filters.get('waterfront'):
        filter_state["waterfront"] = {"value": True}

    search_state = {
        "pagination": {},
        "isMapVisible": True,
        "filterState": filter_state,
    }

    # URL encode the search state
    encoded = urllib.parse.quote(json.dumps(search_state))

    # Map region to URL path
    region_lower = region.lower().replace(' ', '-')
    state_map = {
        'vermont': 'vt',
        'new hampshire': 'nh',
        'maine': 'me',
        'vt': 'vt',
        'nh': 'nh',
        'me': 'me',
    }

    state_code = state_map.get(region_lower, region_lower)
    return f"https://www.zillow.com/{state_code}/?searchQueryState={encoded}"

def extract_search_results(tab_id: str) -> dict:
    """Extract search results from Zillow page via __NEXT_DATA__."""
    js_code = """
    const data = window.__NEXT_DATA__?.props?.pageProps;
    if (data?.searchPageState?.cat1?.searchResults?.listResults) {
        const results = data.searchPageState.cat1.searchResults.listResults;
        JSON.stringify({
            totalResults: data.searchPageState.cat1.searchResults.totalResultCount,
            results: results.map(r => ({
                zpid: r.zpid,
                address: r.address,
                price: r.unformattedPrice,
                beds: r.beds,
                baths: r.baths,
                sqft: r.area,
                lotAcres: r.lotAreaValue && r.lotAreaUnit === 'acres' ? r.lotAreaValue : (r.lotSize ? r.lotSize / 43560 : null),
                latLong: [r.latLong?.latitude, r.latLong?.longitude],
                statusType: r.statusType,
                imgSrc: r.imgSrc,
                detailUrl: r.detailUrl,
            }))
        });
    } else {
        JSON.stringify({error: 'No results found', keys: Object.keys(data || {})});
    }
    """
    result = subprocess.run(
        [CHROME_CLI, "js", tab_id, js_code],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        return {"error": result.stderr}

    try:
        return json.loads(result.stdout.strip())
    except json.JSONDecodeError:
        return {"error": "Could not parse results", "raw": result.stdout[:500]}

def extract_property_details(tab_id: str) -> dict:
    """Extract property details from a Zillow property page."""
    js_code = """
    const data = window.__NEXT_DATA__?.props?.pageProps?.componentProps?.gdpClientCache;
    if (data) {
        const parsed = JSON.parse(data);
        const key = Object.keys(parsed)[0];
        const prop = parsed[key]?.property;
        if (prop) {
            JSON.stringify({
                zpid: prop.zpid,
                address: prop.streetAddress,
                city: prop.city,
                state: prop.state,
                zip: prop.zipcode,
                price: prop.price,
                status: prop.homeStatus,
                beds: prop.bedrooms,
                baths: prop.bathrooms,
                sqft: prop.livingArea,
                lotSqFt: prop.lotSize,
                lotAcres: prop.lotSize ? prop.lotSize / 43560 : null,
                yearBuilt: prop.yearBuilt,
                zestimate: prop.zestimate,
                homeType: prop.homeType,
                photoCount: prop.photoCount,
                taxAssessedValue: prop.taxAssessedValue,
                description: prop.description,
            });
        } else {
            JSON.stringify({error: 'Property not found in data'});
        }
    } else {
        JSON.stringify({error: 'No client cache data'});
    }
    """
    result = subprocess.run(
        [CHROME_CLI, "js", tab_id, js_code],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        return {"error": result.stderr}

    try:
        return json.loads(result.stdout.strip())
    except json.JSONDecodeError:
        return {"error": "Could not parse details", "raw": result.stdout[:500]}

def format_search_results(data: dict) -> None:
    """Pretty print search results."""
    if 'error' in data:
        console.print(f"[red]Error: {data['error']}[/red]")
        return

    total = data.get('totalResults', 0)
    results = data.get('results', [])

    console.print(f"\n[bold green]Found {total} properties[/bold green]")

    if not results:
        return

    table = Table()
    table.add_column("Address", style="cyan", max_width=35)
    table.add_column("Price", justify="right")
    table.add_column("Bed/Bath")
    table.add_column("Sqft")
    table.add_column("Acres", justify="right")
    table.add_column("ZPID")

    for r in results[:20]:
        price = f"${r.get('price', 0):,}" if r.get('price') else 'N/A'
        beds_baths = f"{r.get('beds', '?')}/{r.get('baths', '?')}"
        sqft = f"{r.get('sqft', 0):,}" if r.get('sqft') else 'N/A'
        acres = f"{r.get('lotAcres', 0):.1f}" if r.get('lotAcres') else 'N/A'

        table.add_row(
            r.get('address', 'N/A')[:35],
            price,
            beds_baths,
            sqft,
            acres,
            str(r.get('zpid', 'N/A'))
        )

    console.print(table)

def format_property_details(data: dict) -> None:
    """Pretty print property details."""
    if 'error' in data:
        console.print(f"[red]Error: {data['error']}[/red]")
        return

    console.print("\n[bold green]Property Details:[/bold green]")

    table = Table(show_header=False)
    table.add_column("Field", style="cyan", width=20)
    table.add_column("Value")

    table.add_row("Address", f"{data.get('address', 'N/A')}, {data.get('city', '')}, {data.get('state', '')} {data.get('zip', '')}")
    table.add_row("Status", data.get('status', 'N/A'))

    if data.get('price'):
        table.add_row("Price", f"${data['price']:,}")
    if data.get('zestimate'):
        table.add_row("Zestimate", f"${data['zestimate']:,}")

    table.add_row("Beds", str(data.get('beds', 'N/A')))
    table.add_row("Baths", str(data.get('baths', 'N/A')))

    if data.get('sqft'):
        table.add_row("Sqft", f"{data['sqft']:,}")
    if data.get('lotAcres'):
        table.add_row("Lot Size", f"{data['lotAcres']:.2f} acres")
    if data.get('yearBuilt'):
        table.add_row("Year Built", str(data['yearBuilt']))
    if data.get('homeType'):
        table.add_row("Type", data['homeType'])
    if data.get('photoCount'):
        table.add_row("Photos", str(data['photoCount']))

    console.print(table)

def main():
    parser = argparse.ArgumentParser(description="Zillow property search CLI")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Search command
    search_parser = subparsers.add_parser("search", help="Search for properties")
    search_parser.add_argument("region", help="Region to search (e.g., 'Vermont', 'VT', 'NH')")
    search_parser.add_argument("--beds", type=int, help="Minimum bedrooms")
    search_parser.add_argument("--baths", type=int, help="Minimum bathrooms")
    search_parser.add_argument("--min-price", type=int, help="Minimum price")
    search_parser.add_argument("--max-price", type=int, help="Maximum price")
    search_parser.add_argument("--min-sqft", type=int, help="Minimum square feet")
    search_parser.add_argument("--min-acres", type=float, help="Minimum lot size in acres")
    search_parser.add_argument("--waterfront", action="store_true", help="Waterfront only")
    search_parser.add_argument("--json", action="store_true", help="Output raw JSON")

    # Lookup command (autocomplete)
    lookup_parser = subparsers.add_parser("lookup", help="Look up an address")
    lookup_parser.add_argument("address", help="Address to look up")
    lookup_parser.add_argument("--json", action="store_true", help="Output raw JSON")

    # Details command
    details_parser = subparsers.add_parser("details", help="Get property details by ZPID")
    details_parser.add_argument("zpid", help="Zillow Property ID")
    details_parser.add_argument("--json", action="store_true", help="Output raw JSON")

    args = parser.parse_args()

    if args.command == "search":
        # Build search URL with filters
        filters = {}
        if args.beds:
            filters['min_beds'] = args.beds
        if args.baths:
            filters['min_baths'] = args.baths
        if args.min_price:
            filters['min_price'] = args.min_price
        if args.max_price:
            filters['max_price'] = args.max_price
        if args.min_sqft:
            filters['min_sqft'] = args.min_sqft
        if args.min_acres:
            filters['min_lot_sqft'] = int(args.min_acres * 43560)
        if args.waterfront:
            filters['waterfront'] = True

        url = build_search_url(args.region, **filters)

        # Open or navigate to search URL
        tab_id = get_chrome_tab('zillow.com', url)

        # Navigate to the search URL
        subprocess.run([CHROME_CLI, "navigate", tab_id, url], capture_output=True)

        import time
        time.sleep(3)

        # Extract results
        data = extract_search_results(tab_id)

        if args.json:
            print(json.dumps(data, indent=2))
        else:
            format_search_results(data)

    elif args.command == "lookup":
        data = zillow_autocomplete(args.address)

        if args.json:
            print(json.dumps(data, indent=2))
        else:
            results = data.get('results', [])
            if not results:
                console.print("[yellow]No results found[/yellow]")
            else:
                console.print("\n[bold green]Lookup Results:[/bold green]")
                table = Table()
                table.add_column("Address", style="cyan")
                table.add_column("Type")
                table.add_column("ZPID")

                for r in results[:10]:
                    zpid = r.get('metaData', {}).get('zpid', 'N/A')
                    table.add_row(
                        r.get('display', 'N/A'),
                        r.get('resultType', 'N/A'),
                        str(zpid)
                    )

                console.print(table)

                # If first result has zpid, show hint
                first_zpid = results[0].get('metaData', {}).get('zpid')
                if first_zpid:
                    console.print(f"\n[dim]For details: zillow details {first_zpid}[/dim]")

    elif args.command == "details":
        # Navigate to property page
        url = f"https://www.zillow.com/homedetails/{args.zpid}_zpid/"
        tab_id = get_chrome_tab('zillow.com', url)

        subprocess.run([CHROME_CLI, "navigate", tab_id, url], capture_output=True)

        import time
        time.sleep(3)

        data = extract_property_details(tab_id)

        if args.json:
            print(json.dumps(data, indent=2))
        else:
            format_property_details(data)

    else:
        parser.print_help()

if __name__ == "__main__":
    main()
