#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = ["requests", "rich", "beautifulsoup4"]
# ///
"""
Unified Ski Home Search - Aggregates listings from ALL sources.

Searches 9 sources in parallel:
- Redfin (VT, NH, ME)
- Zillow (VT, NH, ME)
- Hickok & Boardman (VT ski properties)
- Coldwell Banker Lifestyles (VT/NH ski homes)
- Mahoosuc Realty (Sunday River / Bethel ME)

Usage:
    unified-search search                          # Search all with defaults
    unified-search search --beds 3 --max-price 1500000
    unified-search search --json --top 10          # Top 10 as JSON

Output includes image_url for each listing.
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn

console = Console()

CHROME_CLI = Path.home() / ".claude/skills/chrome-control/scripts/chrome"
SCRIPTS_DIR = Path.home() / ".claude/skills/vacation-house/scripts"

DEFAULT_CRITERIA = {
    "min_beds": 3,
    "min_baths": 3,
    "min_acres": 10,
}

# Default home address for driving distance calculation
DEFAULT_HOME = "7 Eastburn St, Brighton, MA"


def get_google_api_key() -> str | None:
    """Get Google API key from macOS Keychain."""
    try:
        result = subprocess.run(
            ["security", "find-generic-password", "-s", "google-api-key", "-w"],
            capture_output=True, text=True, timeout=5
        )
        return result.stdout.strip() if result.returncode == 0 else None
    except:
        return None


def get_driving_distance(origin: str, destination: str, api_key: str) -> dict | None:
    """Get driving distance and duration using Google Routes API."""
    import requests
    url = "https://routes.googleapis.com/directions/v2:computeRoutes"
    headers = {
        "Content-Type": "application/json",
        "X-Goog-Api-Key": api_key,
        "X-Goog-FieldMask": "routes.duration,routes.distanceMeters"
    }
    payload = {
        "origin": {"address": origin},
        "destination": {"address": destination},
        "travelMode": "DRIVE"
    }
    try:
        resp = requests.post(url, json=payload, headers=headers, timeout=10)
        data = resp.json()
        if data.get("routes"):
            route = data["routes"][0]
            meters = route.get("distanceMeters", 0)
            seconds = int(route.get("duration", "0s").rstrip("s"))
            return {
                "miles": round(meters / 1609.34, 1),
                "hours": round(seconds / 3600, 1),
                "minutes": round(seconds / 60)
            }
    except:
        pass
    return None

SKI_MOUNTAINS = {
    "Stowe": (44.5303, -72.7814, "Stowe Mountain Resort, Stowe, VT"),
    "Sugarbush": (44.1353, -72.9033, "Sugarbush Resort, Warren, VT"),
    "Killington": (43.6045, -72.8201, "Killington Resort, Killington, VT"),
    "Okemo": (43.4012, -72.7170, "Okemo Mountain Resort, Ludlow, VT"),
    "Stratton": (43.1134, -72.9081, "Stratton Mountain Resort, Stratton, VT"),
    "Mount Snow": (42.9601, -72.9201, "Mount Snow Resort, West Dover, VT"),
    "Jay Peak": (44.9375, -72.5053, "Jay Peak Resort, Jay, VT"),
    "Burke Mountain": (44.5856, -71.9025, "Burke Mountain, East Burke, VT"),
    "Loon Mountain": (44.0364, -71.6214, "Loon Mountain Resort, Lincoln, NH"),
    "Cannon Mountain": (44.1567, -71.6986, "Cannon Mountain, Franconia, NH"),
    "Bretton Woods": (44.2589, -71.4392, "Bretton Woods, Bretton Woods, NH"),
    "Mount Sunapee": (43.3292, -72.0867, "Mount Sunapee Resort, Newbury, NH"),
    "Gunstock": (43.4497, -71.3603, "Gunstock Mountain Resort, Gilford, NH"),
    "Sunday River": (44.4731, -70.8567, "Sunday River Resort, Newry, ME"),
    "Sugarloaf": (45.0311, -70.3131, "Sugarloaf Mountain Resort, Carrabassett Valley, ME"),
}


def haversine_distance(lat1, lon1, lat2, lon2):
    from math import radians, sin, cos, sqrt, atan2
    R = 3959
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    return R * c


def find_nearest_ski(lat, lon, n=3):
    if not lat or not lon:
        return []
    distances = [(name, haversine_distance(lat, lon, mlat, mlon))
                 for name, (mlat, mlon, _addr) in SKI_MOUNTAINS.items()]
    distances.sort(key=lambda x: x[1])
    return [{"name": n, "miles": round(d, 1)} for n, d in distances[:n]]


def get_ski_driving_distances(listing_address: str, nearest_ski: list, api_key: str, n: int = 2) -> list:
    """Get driving distances from listing to nearest ski mountains."""
    if not listing_address or not nearest_ski or not api_key:
        return []

    results = []
    for ski in nearest_ski[:n]:
        ski_name = ski.get("name")
        if ski_name and ski_name in SKI_MOUNTAINS:
            _lat, _lon, ski_address = SKI_MOUNTAINS[ski_name]
            dist = get_driving_distance(listing_address, ski_address, api_key)
            if dist:
                results.append({
                    "name": ski_name,
                    "drive_miles": dist["miles"],
                    "drive_minutes": dist["minutes"]
                })
    return results


def chrome_js(tab_id, js_code, timeout=10):
    """Execute JS in Chrome tab and return result."""
    try:
        result = subprocess.run(
            [str(CHROME_CLI), "js", str(tab_id), js_code],
            capture_output=True, text=True, timeout=timeout
        )
        return result.stdout.strip() if result.returncode == 0 else None
    except:
        return None


def chrome_open(url):
    """Open URL in Chrome and return tab ID."""
    try:
        result = subprocess.run(
            [str(CHROME_CLI), "open", url],
            capture_output=True, text=True, timeout=15
        )
        match = re.search(r'Opened tab (\d+)', result.stdout)
        if match:
            return match.group(1)
    except:
        pass
    return None


def chrome_navigate(tab_id, url):
    """Navigate existing tab to URL."""
    try:
        subprocess.run(
            [str(CHROME_CLI), "navigate", str(tab_id), url],
            capture_output=True, text=True, timeout=15
        )
        return True
    except:
        return False


def search_redfin(state: str, criteria: dict) -> list:
    """Search Redfin for a state and extract listings with image URLs."""
    state_map = {"VT": "Vermont", "NH": "New-Hampshire", "ME": "Maine"}
    state_name = state_map.get(state, state)

    filters = [
        "property-type=house",
        f"min-beds={criteria.get('min_beds', 3)}",
        f"min-baths={criteria.get('min_baths', 3)}",
        "min-lot-size=10-acre",
        "status=active"
    ]
    if criteria.get('max_price'):
        filters.append(f"max-price={criteria['max_price']}")

    url = f"https://www.redfin.com/state/{state_name}/filter/{','.join(filters)}"

    tab_id = chrome_open(url)
    if not tab_id:
        return []

    time.sleep(4)  # Wait for page to load

    # Extract listings via JS
    js_code = '''
    const listings = [];
    const seen = new Set();
    document.querySelectorAll(".bp-Homecard").forEach(el => {
        const priceEl = el.querySelector("[class*=Price]");
        const statsEl = el.querySelector("[class*=Stats]");
        const addrEl = el.querySelector("[class*=Address]");
        const linkEl = el.querySelector("a[href*='/home/']");
        const imgEl = el.querySelector("img");

        if (!priceEl || !linkEl) return;

        const price = priceEl.textContent.replace(/[^0-9]/g, "");
        const stats = statsEl?.textContent || "";
        const address = addrEl?.textContent?.trim() || "";
        const link = linkEl.href;
        const image = imgEl?.src || "";

        // Parse stats: "5 beds4 baths3,244 sq ft"
        const bedsMatch = stats.match(/(\\d+)\\s*beds?/i);
        const bathsMatch = stats.match(/([\\d.]+)\\s*baths?/i);
        const sqftMatch = stats.match(/([\\d,]+)\\s*sq\\s*ft/i);

        const key = address + price;
        if (!seen.has(key)) {
            seen.add(key);
            listings.push({
                price: parseInt(price) || null,
                beds: bedsMatch ? parseInt(bedsMatch[1]) : null,
                baths: bathsMatch ? parseFloat(bathsMatch[1]) : null,
                sqft: sqftMatch ? parseInt(sqftMatch[1].replace(",", "")) : null,
                address: address,
                url: link,
                image: image
            });
        }
    });
    JSON.stringify(listings);
    '''

    result = chrome_js(tab_id, js_code)

    # Close tab
    subprocess.run([str(CHROME_CLI), "close", str(tab_id)], capture_output=True)

    if not result:
        return []

    try:
        listings = json.loads(result)
        for l in listings:
            l['source'] = f'redfin-{state}'
            l['state'] = state
            # Parse city from address
            if ',' in l.get('address', ''):
                parts = l['address'].split(',')
                if len(parts) >= 2:
                    l['city'] = parts[-2].strip() if len(parts) > 2 else parts[0].strip()
        return listings
    except:
        return []


def search_zillow(state: str, criteria: dict) -> list:
    """Search Zillow for a state."""
    state_map = {"VT": "vt", "NH": "nh", "ME": "me"}
    state_code = state_map.get(state, state.lower())

    filter_state = {
        "beds": {"min": criteria.get('min_beds', 3)},
        "baths": {"min": criteria.get('min_baths', 3)},
        "lot": {"min": 435600},  # 10 acres in sqft
        "con": {"value": False},  # No condos
    }
    if criteria.get('max_price'):
        filter_state["price"] = {"max": criteria['max_price']}

    import urllib.parse
    search_state = {"filterState": filter_state}
    encoded = urllib.parse.quote(json.dumps(search_state))
    url = f"https://www.zillow.com/{state_code}/?searchQueryState={encoded}"

    tab_id = chrome_open(url)
    if not tab_id:
        return []

    time.sleep(4)

    js_code = '''
    const data = window.__NEXT_DATA__?.props?.pageProps;
    if (data?.searchPageState?.cat1?.searchResults?.listResults) {
        const results = data.searchPageState.cat1.searchResults.listResults;
        JSON.stringify(results.slice(0, 30).map(r => ({
            price: r.unformattedPrice,
            beds: r.beds,
            baths: r.baths,
            sqft: r.area,
            acres: r.lotAreaValue && r.lotAreaUnit === "acres" ? r.lotAreaValue : null,
            address: r.address,
            url: r.detailUrl,
            image: r.imgSrc,
            lat: r.latLong?.latitude,
            lon: r.latLong?.longitude
        })));
    } else {
        "[]";
    }
    '''

    result = chrome_js(tab_id, js_code)
    subprocess.run([str(CHROME_CLI), "close", str(tab_id)], capture_output=True)

    if not result or result == "[]":
        return []

    try:
        listings = json.loads(result)
        for l in listings:
            l['source'] = f'zillow-{state}'
            l['state'] = state
        return listings
    except:
        return []


def run_local_cli(name: str, args: list, timeout_sec: int = 60) -> list:
    """Run a local CLI script."""
    script = SCRIPTS_DIR / name
    if not script.exists():
        return []

    try:
        result = subprocess.run(
            [str(script)] + args,
            capture_output=True, text=True, timeout=timeout_sec
        )
        if result.returncode != 0:
            return []

        output = result.stdout.strip()
        if output.startswith('['):
            return json.loads(output)
    except:
        pass
    return []


def search_hickok(criteria: dict) -> list:
    """Search Hickok & Boardman VT ski properties."""
    args = ["search", "--json"]
    if criteria.get('min_beds'):
        args.extend(["--min-beds", str(criteria['min_beds'])])
    if criteria.get('min_baths'):
        args.extend(["--min-baths", str(criteria['min_baths'])])
    if criteria.get('min_acres'):
        args.extend(["--min-acres", str(criteria['min_acres'])])
    if criteria.get('max_price'):
        args.extend(["--max-price", str(criteria['max_price'])])

    return run_local_cli("hickok", args, timeout_sec=30)


def search_cblife(criteria: dict) -> list:
    """Search Coldwell Banker Lifestyles ski homes."""
    args = ["search", "--json"]
    if criteria.get('min_beds'):
        args.extend(["--min-beds", str(criteria['min_beds'])])
    if criteria.get('min_baths'):
        args.extend(["--min-baths", str(criteria['min_baths'])])
    if criteria.get('min_acres'):
        args.extend(["--min-acres", str(criteria['min_acres'])])
    if criteria.get('max_price'):
        args.extend(["--max-price", str(criteria['max_price'])])

    return run_local_cli("cblife", args, timeout_sec=30)


def search_mahoosuc(criteria: dict) -> list:
    """Search Mahoosuc Realty (Sunday River / Bethel ME)."""
    args = ["search", "--json"]
    if criteria.get('min_beds'):
        args.extend(["--min-beds", str(criteria['min_beds'])])
    if criteria.get('min_baths'):
        args.extend(["--min-baths", str(criteria['min_baths'])])
    if criteria.get('min_acres'):
        args.extend(["--min-acres", str(criteria['min_acres'])])
    if criteria.get('max_price'):
        args.extend(["--max-price", str(criteria['max_price'])])

    return run_local_cli("mahoosuc", args, timeout_sec=30)


def normalize_listing(listing: dict) -> dict:
    """Normalize listing fields."""
    price = listing.get('price')
    if isinstance(price, str):
        price = int(re.sub(r'[^0-9]', '', price)) if price else None

    return {
        'price': price,
        'beds': listing.get('beds'),
        'baths': listing.get('baths'),
        'sqft': listing.get('sqft'),
        'acres': listing.get('acres'),
        'address': listing.get('address', ''),
        'city': listing.get('city', ''),
        'state': listing.get('state', ''),
        'url': listing.get('url', ''),
        'image_url': listing.get('image') or listing.get('image_url') or listing.get('imgSrc', ''),
        'source': listing.get('source', 'unknown'),
        'lat': listing.get('lat'),
        'lon': listing.get('lon'),
    }


def score_listing(l: dict, criteria: dict) -> float:
    score = 0.0

    # Has required data
    if l.get('price'):
        score += 10
    if l.get('image_url'):
        score += 5

    # Bedrooms
    beds = l.get('beds') or 0
    score += min(beds, 6) * 5

    # Bathrooms
    baths = l.get('baths') or 0
    score += min(baths, 5) * 3

    # Acreage (big bonus for more land)
    acres = l.get('acres') or 0
    if acres >= 50:
        score += 40
    elif acres >= 20:
        score += 30
    elif acres >= 10:
        score += 20
    elif acres >= 5:
        score += 10

    # Square footage
    sqft = l.get('sqft') or 0
    if sqft >= 4000:
        score += 15
    elif sqft >= 3000:
        score += 10
    elif sqft >= 2000:
        score += 5

    # Ski proximity
    if l.get('lat') and l.get('lon'):
        nearest = find_nearest_ski(l['lat'], l['lon'], n=1)
        if nearest:
            dist = nearest[0]['miles']
            if dist <= 20:
                score += 20
            elif dist <= 40:
                score += 15
            elif dist <= 60:
                score += 10

    # Value score (price per sqft, lower is better)
    if l.get('price') and l.get('sqft') and l['sqft'] > 0:
        ppsf = l['price'] / l['sqft']
        if ppsf < 200:
            score += 15
        elif ppsf < 300:
            score += 10
        elif ppsf < 400:
            score += 5

    return score


def cmd_search(args):
    criteria = {
        'min_beds': args.beds or DEFAULT_CRITERIA['min_beds'],
        'min_baths': args.baths or DEFAULT_CRITERIA['min_baths'],
        'min_acres': args.acres or DEFAULT_CRITERIA['min_acres'],
        'max_price': args.max_price,
    }

    all_listings = []

    if not args.json:
        console.print(f"[bold]Searching all sources...[/bold]")
        console.print(f"[dim]Criteria: {criteria['min_beds']}+ beds, {criteria['min_baths']}+ baths, {criteria['min_acres']}+ acres" +
                      (f", max ${criteria['max_price']:,}" if criteria['max_price'] else "") + "[/dim]\n")

    # Use thread pool to search all sources in parallel
    def search_source(source_info):
        name, func, args_tuple = source_info
        try:
            if args_tuple:
                return name, func(*args_tuple)
            else:
                return name, func(criteria)
        except Exception as e:
            return name, []

    # Build list of all search tasks
    search_tasks = []

    # Redfin for all 3 states
    for state in ["VT", "NH", "ME"]:
        search_tasks.append((f"Redfin {state}", search_redfin, (state, criteria)))

    # Zillow for all 3 states
    for state in ["VT", "NH", "ME"]:
        search_tasks.append((f"Zillow {state}", search_zillow, (state, criteria)))

    # Boutique sources
    search_tasks.append(("Hickok & Boardman", search_hickok, None))
    search_tasks.append(("Coldwell Banker", search_cblife, None))
    search_tasks.append(("Mahoosuc Realty", search_mahoosuc, None))

    if not args.json:
        console.print(f"[dim]Searching {len(search_tasks)} sources in parallel...[/dim]\n")

    # Run all searches in parallel
    with ThreadPoolExecutor(max_workers=8) as executor:
        futures = [executor.submit(search_source, task) for task in search_tasks]
        for future in as_completed(futures):
            source_name, listings = future.result()
            if not args.json:
                console.print(f"  [green]{source_name}: {len(listings)} listings[/green]")
            all_listings.extend([normalize_listing(l) for l in listings])

    # Score all listings
    for l in all_listings:
        l['score'] = score_listing(l, criteria)
        l['nearest_ski'] = find_nearest_ski(l.get('lat'), l.get('lon'), n=3) if l.get('lat') else []

    # Sort by score
    all_listings.sort(key=lambda x: x['score'], reverse=True)

    # Dedupe by address
    seen = set()
    unique = []
    for l in all_listings:
        key = l.get('address', '').lower()[:30]
        if key and key not in seen:
            seen.add(key)
            unique.append(l)

    # Apply max price filter
    if criteria['max_price']:
        unique = [l for l in unique if l.get('price') and l['price'] <= criteria['max_price']]

    # Get top N
    results = unique[:args.top]

    # Add driving distances if home address provided
    if args.home:
        api_key = get_google_api_key()
        if api_key:
            if not args.json:
                console.print(f"\n[dim]Calculating driving distances (home + ski mountains)...[/dim]")

            def get_all_distances_for_listing(listing):
                dest = listing.get('address', '')
                if dest:
                    # Distance from home
                    dist = get_driving_distance(args.home, dest, api_key)
                    if dist:
                        listing['drive_from_home'] = dist

                    # Distances to nearest ski mountains
                    nearest_ski = listing.get('nearest_ski', [])
                    if nearest_ski:
                        ski_drives = get_ski_driving_distances(dest, nearest_ski, api_key, n=2)
                        if ski_drives:
                            listing['ski_driving'] = ski_drives
                return listing

            # Get distances in parallel
            with ThreadPoolExecutor(max_workers=5) as executor:
                results = list(executor.map(get_all_distances_for_listing, results))

            if not args.json:
                console.print(f"  [green]Done![/green]")

    if args.json:
        output = []
        for l in results:
            output.append({
                'price': l.get('price'),
                'beds': l.get('beds'),
                'baths': l.get('baths'),
                'sqft': l.get('sqft'),
                'acres': l.get('acres'),
                'address': l.get('address'),
                'city': l.get('city'),
                'state': l.get('state'),
                'url': l.get('url'),
                'image_url': l.get('image_url'),
                'source': l.get('source'),
                'score': l.get('score'),
                'nearest_ski': l.get('nearest_ski'),
                'drive_from_home': l.get('drive_from_home'),
                'ski_driving': l.get('ski_driving'),
            })
        print(json.dumps(output, indent=2))
        return 0

    # Display table
    console.print(f"\n[bold green]Top {len(results)} Results[/bold green] (from {len(all_listings)} total)\n")

    table = Table()
    table.add_column("#", style="dim", justify="right")
    table.add_column("Price", style="green", justify="right")
    table.add_column("Bed/Ba", justify="center")
    table.add_column("SqFt", justify="right")
    table.add_column("Acres", justify="right")
    table.add_column("Address", style="cyan", max_width=35)
    table.add_column("Source", style="dim")

    for i, l in enumerate(results, 1):
        price_str = f"${l['price']:,}" if l.get('price') else "-"
        bb = f"{l.get('beds') or '?'}/{l.get('baths') or '?'}"
        sqft_str = f"{l['sqft']:,}" if l.get('sqft') else "-"
        acres_str = f"{l['acres']:.1f}" if l.get('acres') else "-"
        addr = l.get('address', '')[:35]

        table.add_row(str(i), price_str, bb, sqft_str, acres_str, addr, l.get('source', ''))

    console.print(table)

    return 0


def main():
    parser = argparse.ArgumentParser(description="Unified Ski Home Search")
    subparsers = parser.add_subparsers(dest="command")

    sp = subparsers.add_parser("search", help="Search all sources")
    sp.add_argument("--beds", type=int, help="Min bedrooms")
    sp.add_argument("--baths", type=int, help="Min bathrooms")
    sp.add_argument("--acres", type=float, help="Min acreage")
    sp.add_argument("--max-price", type=int, help="Max price")
    sp.add_argument("--top", type=int, default=20, help="Top N results")
    sp.add_argument("--json", action="store_true", help="JSON output")
    sp.add_argument("--home", type=str, default=DEFAULT_HOME, help="Home address for driving distance")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    if args.command == "search":
        return cmd_search(args)

    return 0


if __name__ == "__main__":
    sys.exit(main())
