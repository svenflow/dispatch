#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = ["requests", "rich", "beautifulsoup4"]
# ///
"""
Mahoosuc Realty CLI - Sunday River / Bethel Maine ski properties

Uses IDXBroker URL parameters to search Maine ski area homes.

Usage:
    mahoosuc search                    # All active listings in Bethel area
    mahoosuc search --beds 3           # 3+ bedrooms
    mahoosuc search --min-acres 1      # 1+ acres
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from pathlib import Path

import requests
from bs4 import BeautifulSoup
from rich.console import Console
from rich.table import Table

console = Console()

CHROME_CLI = Path.home() / ".claude/skills/chrome-control/scripts/chrome"

# IDXBroker base URL for Mahoosuc Realty
BASE_URL = "https://mahoosucrealty.idxbroker.com/idx/search"

# Town codes for ski areas
TOWN_CODES = {
    "bethel": "144",
    "newry": "165",  # Sunday River
    "greenwood": "146",
}


def build_search_url(**filters) -> str:
    """Build IDXBroker search URL with filters."""
    params = []

    # Default to Bethel area (Sunday River)
    if filters.get("town"):
        town_code = TOWN_CODES.get(filters["town"].lower(), "144")
        params.append(f"ccz={town_code}")

    # Property type - single family only (exclude condos)
    params.append("a_propSubType[]=Single%20Family")

    # Status - active listings
    params.append("a_propStatus[]=Active")

    # Bedrooms
    if filters.get("min_beds"):
        params.append(f"bd={filters['min_beds']}")

    # Bathrooms
    if filters.get("min_baths"):
        params.append(f"ba={filters['min_baths']}")

    # Price
    if filters.get("min_price"):
        params.append(f"lp={filters['min_price']}")
    if filters.get("max_price"):
        params.append(f"hp={filters['max_price']}")

    # Acreage
    if filters.get("min_acres"):
        params.append(f"amin_acres={filters['min_acres']}")
    if filters.get("max_acres"):
        params.append(f"amax_acres={filters['max_acres']}")

    return f"{BASE_URL}?{'&'.join(params)}"


def get_chrome_tab(site_pattern: str, open_url: str = None) -> str:
    """Find or open a Chrome tab matching the pattern."""
    result = subprocess.run([str(CHROME_CLI), "tabs"], capture_output=True, text=True)

    tab_id = None
    lines = result.stdout.strip().split('\n')
    for i, line in enumerate(lines):
        if site_pattern in line.lower():
            if i > 0:
                prev_line = lines[i - 1].strip()
                parts = prev_line.split()
                if parts and parts[0].isdigit():
                    tab_id = parts[0]
                    break

    if not tab_id and open_url:
        result = subprocess.run(
            [str(CHROME_CLI), "open", open_url],
            capture_output=True,
            text=True,
        )
        match = re.search(r'Opened tab (\d+)', result.stdout)
        if match:
            tab_id = match.group(1)
            time.sleep(4)  # IDXBroker needs time to load

    if not tab_id:
        raise RuntimeError(f"Could not find or open {site_pattern} tab")

    return tab_id


def extract_listings(tab_id: str) -> list[dict]:
    """Extract listing data from IDXBroker results page."""
    # IDXBroker renders listings as HTML cards
    js_code = """
    const listings = [];
    document.querySelectorAll('.IDX-resultsRow, .IDX-propertyResult, .listing-result, [class*="propertyRow"]').forEach(el => {
        const getText = (sel) => {
            const e = el.querySelector(sel);
            return e ? e.textContent.trim() : null;
        };
        const getAttr = (sel, attr) => {
            const e = el.querySelector(sel);
            return e ? e.getAttribute(attr) : null;
        };

        // Try various selectors for different IDXBroker themes
        const priceText = getText('.IDX-price, .price, [class*="price"]') || '';
        const price = priceText.replace(/[^0-9]/g, '');

        const address = getText('.IDX-address, .address, [class*="address"]');
        const cityState = getText('.IDX-cityState, .city-state, [class*="cityState"]');

        const beds = getText('.IDX-beds, .beds, [class*="beds"]');
        const baths = getText('.IDX-baths, .baths, [class*="baths"]');
        const sqft = getText('.IDX-sqft, .sqft, [class*="sqft"]');
        const acres = getText('.IDX-acres, .acres, [class*="acres"], [class*="lot"]');

        const link = getAttr('a[href*="/idx/details/"]', 'href') || getAttr('a', 'href');
        const img = getAttr('img', 'src');

        if (address || price) {
            listings.push({
                price: price ? parseInt(price) : null,
                address: address,
                city_state: cityState,
                beds: beds ? parseInt(beds.replace(/[^0-9]/g, '')) : null,
                baths: baths ? parseFloat(baths.replace(/[^0-9.]/g, '')) : null,
                sqft: sqft ? parseInt(sqft.replace(/[^0-9]/g, '')) : null,
                acres: acres ? parseFloat(acres.replace(/[^0-9.]/g, '')) : null,
                url: link,
                image: img
            });
        }
    });
    JSON.stringify(listings);
    """

    result = subprocess.run(
        [str(CHROME_CLI), "js", tab_id, js_code],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        console.print(f"[red]Error extracting listings: {result.stderr}[/red]")
        return []

    try:
        return json.loads(result.stdout.strip())
    except json.JSONDecodeError:
        console.print(f"[yellow]Could not parse listings. Raw output: {result.stdout[:200]}[/yellow]")
        return []


def cmd_search(args):
    """Search for ski area listings."""
    filters = {}
    if args.town:
        filters["town"] = args.town
    if args.min_beds:
        filters["min_beds"] = args.min_beds
    if args.min_baths:
        filters["min_baths"] = args.min_baths
    if args.min_price:
        filters["min_price"] = args.min_price
    if args.max_price:
        filters["max_price"] = args.max_price
    if args.min_acres:
        filters["min_acres"] = args.min_acres

    url = build_search_url(**filters)
    console.print(f"[dim]Searching: {url}[/dim]")

    # Open or navigate to search URL
    tab_id = get_chrome_tab('mahoosucrealty', url)

    # Navigate to the search URL
    subprocess.run([str(CHROME_CLI), "navigate", tab_id, url], capture_output=True)
    time.sleep(4)

    # Extract listings
    listings = extract_listings(tab_id)

    if args.json:
        print(json.dumps(listings, indent=2))
        return 0

    console.print(f"\n[bold]Sunday River / Bethel ME Homes[/bold] - {len(listings)} listings\n")

    if not listings:
        console.print("[yellow]No listings found. Try adjusting filters.[/yellow]")
        return 0

    table = Table()
    table.add_column("Price", style="green", justify="right")
    table.add_column("Beds", justify="center")
    table.add_column("Baths", justify="center")
    table.add_column("SqFt", justify="right")
    table.add_column("Acres", justify="right")
    table.add_column("Address", style="cyan")

    for l in listings[:20]:
        price_str = f"${l['price']:,}" if l.get('price') else "-"
        beds_str = str(l.get('beds', '-'))
        baths_str = str(l.get('baths', '-'))
        sqft_str = f"{l['sqft']:,}" if l.get('sqft') else "-"
        acres_str = f"{l['acres']:.2f}" if l.get('acres') else "-"
        addr = l.get('address', 'N/A')

        table.add_row(price_str, beds_str, baths_str, sqft_str, acres_str, addr[:40])

    console.print(table)

    if len(listings) > 20:
        console.print(f"\n[dim]Showing 20 of {len(listings)} results[/dim]")

    return 0


def main():
    parser = argparse.ArgumentParser(description="Mahoosuc Realty - Sunday River/Bethel ME")
    subparsers = parser.add_subparsers(dest="command", help="Commands")

    search_parser = subparsers.add_parser("search", help="Search listings")
    search_parser.add_argument("--town", help="Town name (bethel, newry, greenwood)")
    search_parser.add_argument("--min-beds", type=int, help="Minimum bedrooms")
    search_parser.add_argument("--min-baths", type=int, help="Minimum bathrooms")
    search_parser.add_argument("--min-price", type=int, help="Minimum price")
    search_parser.add_argument("--max-price", type=int, help="Maximum price")
    search_parser.add_argument("--min-acres", type=float, help="Minimum acreage")
    search_parser.add_argument("--json", action="store_true", help="Output JSON")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    if args.command == "search":
        return cmd_search(args)

    return 0


if __name__ == "__main__":
    sys.exit(main())
